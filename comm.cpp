
#include "comm.h"
// Find the directory and the name of the file specified by wholename, return the directory and the file name which are in
// string filename and dirc, for example, 
// wholename="/mydata/abc/foo.data", then the function return
// filename="foo.data"
// dirc="/mydata/abc/"
//
int find_filename(string wname, string& filename, string& dirc) 
{

    char c='/'; 
    int pos;
    pos=wname.find_last_of(c); 
    if (pos == string::npos)
    {
	filename=wname;
	dirc="";
    }
    else
    {
	dirc=wname.substr(0,pos+1);
	filename=wname.substr(pos+1);
    }
    return 0; 
}

// Find the directory and the name of the file specified by wholename, return the directory and the file name which are in
// string filename and dirc, for example, 
// wholename="/mydata/abc/foo.data", then the function return
// filename="foo.data"
// dirc="/mydata/abc/"
//
int find_filename(char* wholename, string& filename, string& dirc) 
{

    char c='/'; 
    int pos;
    string wname=wholename;   
    pos=wname.find_last_of(c); 
    if (pos == string::npos)
    {
	filename=wname;
	dirc="";
    }
    else
    {
	dirc=wname.substr(0,pos+1);
	filename=wname.substr(pos+1);
    }
    return 0; 
}

// convert an integer to a string
string itos(int i)
{
    stringstream stm;
    stm<<i;
    return stm.str();
}

// Read a remote sensing time series image file and divide it into a number of small files, the file must be in BSQ format
// ifname, name of input file
// parts, the number of subset the program intends to divide the input file into
// pnum, the total number of the pixels
// ts, the number of time series (band) contained in the image file
// sf, the number of bytes per pixels in the input file
//


int div_afile(char* ifname, int parts, int pnum, int ts, int sf)
{
    ofstream ofs; 
    ofstream* fout;
    ifstream fin;

    string pr, ofname; 
    float* wdata;
    int i, j, s, bs, be, rbs, ind;

    wdata = new float[pnum*ts];
    fout=new ofstream[parts];

    fin.open(ifname, ios::binary|ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file.\n";
	return -2;
    }
    else
    {
	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }



    fin.read((char*)wdata, pnum*ts*sf);	

    for(i=0;i<12;i++)
    {
	cout<<wdata[i]<<" ";
    }
    cout<<endl;

    pr=".part";

    if (pnum%parts ==0)
    {
	bs=pnum/parts;
    }
    else
    {
	bs=(int)floor(pnum/parts)+1;
    }

    for (s=0;s<parts;s++)
    {
	ofname = ifname+pr+itos(s);
	fout[s].open(ofname.c_str(), ios::out|ios::binary);
	if (!fout[s].good())
	{
	    cout<<"Fail to open the output file.\n";
	    return -3;
	}
	else
	{
	    cout<<"Open output file "<<ofname<<" successfully"<<endl;
	}
    }

    for(i=0;i<ts;i++)
    {
	ind=i*pnum;
	for(j=0;j<parts;j++)
	{
	    be=j*bs;
	    if (be+bs>pnum)
	    {
		rbs=pnum-be;
	    }
	    else
	    {
		rbs=bs;
	    }
	    if (i==0)
	    {	
		fout[j].write((char*) &rbs, sizeof(int));
		fout[j].write((char*) &ts, sizeof(int));
		fout[j].write((char*) &sf, sizeof(int));
	    }
	    fout[j].write((char*) &wdata[ind+be], rbs*sf);
	}
    }
    fin.close();
    for(j=0;j<parts;j++)
    {
	fout[j].close();
    }
    delete [] wdata;
    delete [] fout;
    return 0;
}

// Read a RS image file generated by dividing a large RS image file using the function divide_afile
// ifname, the name of the image file
// header, store the information of the image files, the number of pixels per time sequence, the number of time series, the number of bytes per pixels 
// in the image file    
int read_subfile(const char* ifname, float*& data, int*& header, int cls)
{
    ifstream fin;
    int pnum, ts, sf;	

    fin.open(ifname, ios::binary|ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file.\n";
	return -2;
    }
    else
    {
	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }

    if (cls==0)
    {
	header  = new int[3];
	fin.read((char*)header, 3*sizeof(int));
    }
    pnum=header[0];
    ts=header[1];
    sf=header[2];

    data=new float[pnum*ts];
    fin.read((char*)data, pnum*ts*sf);

    // cout<<data[0]<<"  "<<data[pnum]<<endl;
    fin.close();
    return 0;
}

// Counting the number of lines in the file
int countlines(string fname)
{
    int ncc;
    
    ifstream fin;
    char buf[256*1024];    

    fin.open(fname.c_str());
    
    if (!fin.good())
    {
	return -1;
    }


    ncc=0;


    while (1)
    {
	fin.getline(buf, 1024*256, '\n');
	if(fin.eof())
	{
	    break;
	}
	ncc++;
    }

    fin.close();

    
    return ncc;
}



// Counting the number of lines and the number of items in each line of a text based data file, the number of instances of each line
// are stored at vector items, the input file stream is specified by fin and the delimited char is specified by det
int countlines(ifstream& fin, vector<int>& items)
{
    int ncc, dcc;
    items.clear();
    fin.seekg(ios::beg);
    char c, rt;
    bool flag;

    rt='\n';

    ncc=dcc=0;

    flag=false;
    while (1)
    {
	fin.get(c);
	if(fin.eof())
	{
	    break;
	}
	if ((c=='\t' || c==' ' || c==',') && flag)
	{    
	    dcc++;
	    flag=false;
	}
	else if (c==rt) 
	{
	    if (flag)
	    {
		items.push_back(dcc+1);
	    }
	    else
	    {
		items.push_back(dcc);
	    }
	    dcc=0;
	    ncc++;
	    flag=false;
	}
	else if ((c>='0' && c<='9') || (c>='a' && c<='z') || (c>='A' && c<='Z') || (c=='+' || c=='-'))
	{
	    flag=true;
	}
    }
    //cout<<"ncc="<<ncc<<" items.size()="<<items.size()<<" items[0]="<<items[0]<<endl;
    return ncc;
}

// reading data from a text based data file, store the data into array data in row order, 
// ignoring the first coln columns,  ignoring the first nrow rows,
//the number of instances of each line are stored at vector items, the input file 
//is specified by ifname and the delimited char is specified by det

int readtxtdata(const char* ifname, int nrow, int coln, double*& data, vector<int>& items, long& irow, long& icol)
{
    ifstream fin;
    int i, j, ncc, sum, cc, dcc, ss, be, len;
    char buf[1024*256];
    char c;
    string st, sst;
    bool flag;

    fin.open(ifname, ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file "<<ifname<<"\n";
	return -2;
    }
    else
    {
	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }


    items.clear();
    ncc=countlines(fin, items);

    fin.clear();
    fin.seekg(ios::beg);
    //   cout<<"# of lines="<<ncc<<endl;
    sum=0;
    for (i=0;i<ncc;i++)
    {
	sum+=items[i];
	//	cout<<items[i]<<endl;
    }
  //  data =new double[sum-ncc*coln];
    
    for(i=0;i<nrow;i++)
    {
	fin.getline(buf, 1024*256, '\n');
    }

    ncc-=nrow;
    irow=ncc;
    icol=items[nrow]-coln;

    data =new double[irow*icol];
    cc=0;
    for (i=0;i<ncc;i++)
    {
	getline(fin,st);

	//fin.getline(buf, 1024*256, '\n');
	//st=buf;
	ss=st.size();
	dcc=0;
	flag=false;
	for(j=0;j<ss;j++)
	{
	    c=st[j];
	    if (((c>='0' && c<='9') || (c>='a' && c<='z') || (c>='A' && c<='Z') || c=='.' || c=='-') && !flag)
	    {
		flag=true;
		be=j;
	    }
	    else if (flag &&(c==' ' || c==',' || c=='\t' || j==ss-1))
	    {
		flag=false;
		dcc++;
		if (dcc>coln)
		{
		    len=j-be;
		    if (j==ss-1)
		    {
			len++;
		    }
		    sst=st.substr(be, len);
		    data[cc]=atof(sst.c_str());
		    cc++;
		}

	    }
	}
	if (flag)
	{
	    len=j-be;
	    sst=st.substr(be, len);
	    data[cc]=atof(sst.c_str());
	    cc++;
	}
    }
    return sum-ncc*coln;
}



// reading data from a text based data file, store the data into array data in row order, 
// ignoring the first coln columns,  ignoring the first nrow rows,
//the number of instances of each line are stored at vector items, the input file 
//is specified by ifname and the delimited char is specified by det

int readtxtdata(const char* ifname, int nrow, int coln, double*& data, vector<int>& items)
{
    ifstream fin;
    int i, j, ncc, sum, cc, dcc, ss, be, len;
    char buf[1024*256];
    char c;
    string st, sst;
    bool flag;

    fin.open(ifname, ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file "<<ifname<<"\n";
	return -2;
    }
    else
    {
	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }

    ncc=countlines(fin, items);

    fin.clear();
    fin.seekg(ios::beg);
    //   cout<<"# of lines="<<ncc<<endl;
    sum=0;
    for (i=0;i<ncc;i++)
    {
	sum+=items[i];
	//	cout<<items[i]<<endl;
    }
    data =new double[sum-ncc*coln];
    
    for(i=0;i<nrow;i++)
    {
	fin.getline(buf, 1024*256, '\n');
    }


    cc=0;
    for (i=0;i<ncc;i++)
    {
	getline(fin,st);
	//fin.getline(buf, 1024*256, '\n');
	//st=buf;
	ss=st.size();
	dcc=0;
	flag=false;
	for(j=0;j<ss;j++)
	{
	    c=st[j];
	    if (((c>='0' && c<='9') || (c>='a' && c<='z') || (c>='A' && c<='Z') || c=='.' || c=='-') && !flag)
	    {
		flag=true;
		be=j;
	    }
	    else if (flag &&(c==' ' || c==',' || c=='\t' || j==ss-1))
	    {
		flag=false;
		dcc++;
		if (dcc>coln)
		{
		    len=j-be;
		    if (j==ss-1)
		    {
			len++;
		    }
		    sst=st.substr(be, len);
		    data[cc]=atof(sst.c_str());
		    cc++;
		}

	    }
	}
	if (flag)
	{
	    len=j-be;
	    sst=st.substr(be, len);
	    data[cc]=atof(sst.c_str());
	    cc++;
	}
    }
    return sum-ncc*coln;
}


// reading data from a text based data file, store the data into array data in row order, ignoring the first coln columns, 
//the number of instances of each line are stored at vector items, the input file 
//is specified by ifname and the delimited char is specified by det

int readtxtdata(const char* ifname, int coln, double*& data, vector<int>& items)
{
    ifstream fin;
    int i, j, ncc, sum, cc, dcc, ss, be, len;
    char buf[1024*256];
    char c;
    string st, sst;
    bool flag;

    fin.open(ifname, ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file "<<ifname<<"\n";
	return -2;
    }
    else
    {
	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }

    ncc=countlines(fin, items);

    fin.clear();
    fin.seekg(ios::beg);
    //   cout<<"# of lines="<<ncc<<endl;
    sum=0;
    for (i=0;i<ncc;i++)
    {
	sum+=items[i];
	//	cout<<items[i]<<endl;
    }
    data =new double[sum-ncc*coln];
    cc=0;
    for (i=0;i<ncc;i++)
    {
	getline(fin,st);
	//fin.getline(buf, 1024*256, '\n');
	//st=buf;
	ss=st.size();
	dcc=0;
	flag=false;
	for(j=0;j<ss;j++)
	{
	    c=st[j];
	    if (((c>='0' && c<='9') || (c>='a' && c<='z') || (c>='A' && c<='Z') || c=='.' || c=='-') && !flag)
	    {
		flag=true;
		be=j;
	    }
	    else if (flag &&(c==' ' || c==',' || c=='\t' || j==ss-1))
	    {
		flag=false;
		dcc++;
		if (dcc>coln)
		{
		    len=j-be;
		    sst=st.substr(be, len);
		    data[cc]=atof(sst.c_str());
		    cc++;
		}

	    }
	}
	if (flag)
	{
	    len=j-be;
	    sst=st.substr(be, len);
	    data[cc]=atof(sst.c_str());
	    cc++;
	}
    }
    return sum-ncc*coln;
}

// form index of combination vectors from multiple classes, the number of distinct instances of each class is specified by s and the returning index
// vectors is stored in comb, e.g., (5, 4, 3) -> (0,0,0), (0,0,1), ..., (2, 3, 2), (3, 0, 0), ..., (4,3,2), to generate combinations that with various 
// number of vector, put ad=1, in such cases vector (2, -1, 3) means a two-component vector (2,3), otherwise, set ad=0; 
int getcomb(vector<int>& s, vector< vector<int> >& comb, int ad)
{
    int i, j, num, ss, total, lsum;
    vector <int> ind;

    ss=s.size();
    if (ss==0)
    {
	return 0;
    }
    total=1;
    for (i=0;i<ss;i++)
    {
	s[i]+=ad;
	total*=s[i];
    }
    comb.clear();
    ind.clear();
    comb.assign(total,ind);
    ind.assign(ss+1,0);
    for(i=0;i<total;i++)
    {
	comb[i]=ind;
    }
    for(i=0;i<total;i++)
    {
	num=i;
	for (j=ss-1;j>=0;j--)
	{
	    comb[i][j]=num%s[j];
	    num-=comb[i][j];
	    num/=s[j];
	}
	comb[i][ss]=0;
	for(j=0;j<ss;j++)
	{
	    comb[i][j]-=ad;
	    if (comb[i][j]>=0)
	    {
		comb[i][ss]++;
	    }
	}
    }
    /*
       for (j=0;j<total;j++)
       {
       for(i=0;i<ss;i++)
       {
       cout<<comb[j][i]<<" ";
       }
       cout<<endl;
       }
       */
    for (i=0;i<ss;i++)
    {
	s[i]-=ad;
    }
    return total;
}

// generate a set of endmember signatures with orthonormal base by combining distinct EM signatures values of each endmember in libraries, 
// the EM signature library is given by array em, number of signatures for each EM class is given by vector its, the returned orthonormal EM sets
// are stored in emsets and the original EM sets are stored into og_emsets
int orthonormalemsets(vector<int>& its, int band, vector< vector<int> >& comb_ind, double** em, vector<gsl_matrix*>& emsets, vector<gsl_matrix*>& og_emsets)

{
    int i, j,  k, ss, nms, ind, dm, cc;
    gsl_matrix* gms, *ogms;

    nms=its.size();
    ss= comb_ind.size();

    for(i=0;i<nms;i++)
	cout<<its[i]<<" ";

    cout<<endl;

    for (i=0;i<ss;i++)
    {
	dm=comb_ind[i][nms];
	//	if (dm>1)
	if (dm>0)
	{
	    gms=gsl_matrix_calloc(band, dm);
	    ogms=gsl_matrix_calloc(band, dm);
	    cc=0;
	    for (j=0;j<nms;j++)     // j represents the index of endmember, j=0 for bs, j=1 for  gv, j=2 for npv
	    {
		ind=comb_ind[i][j];    // get index number of corresponding em signature 
		if (ind<0)
		{
		    continue;
		}
		for (k=0;k<band;k++)  // read em signature values from item[j] and put them into corresponding line in matrix gms
		{
		    gsl_matrix_set(gms, k, cc, em[j][k*its[j]+ind]);
		}
		cc++;
		//	cout<<"cc="<<cc<<endl;
	    }
	    gsl_matrix_memcpy(ogms, gms);
	    orthonormalize(gms, band, dm);
	}
	else
	{
	    gms=gsl_matrix_calloc(band, 1);
	    ogms=gsl_matrix_calloc(band, 1);
	    gsl_matrix_memcpy(ogms, gms);
	}
	og_emsets.push_back(ogms);
	emsets.push_back(gms);
    }
}



// find an orthonormal base in from a set of m independent (n-dimensional) vectors specified by row vectors in gms
int orthonormalize(gsl_matrix* gms, int n, int m)
{   
    int i,j;
    double sc, dd;
    gsl_vector *vi, *vj;

    vi=gsl_vector_alloc(n);
    vj=gsl_vector_alloc(n);

    for (i=0;i<m;i++)
    {
	gsl_matrix_get_col(vi, gms, i);
	for(j=0;j<i;j++)
	{
	    gsl_matrix_get_col(vj, gms, j);
	    gsl_blas_ddot(vi,vj,&dd);
	    gsl_vector_scale(vj,dd);
	    gsl_vector_sub(vi,vj);
	}
	sc = 1.0 / gsl_blas_dnrm2(vi); 
	gsl_vector_scale(vi,sc); 
	gsl_matrix_set_col(gms,i,vi);	
    }
    /*
       gsl_matrix_get_row(vj, gms, 0);
       gsl_matrix_get_row(vi, gms, 1);
       gsl_blas_ddot(vi,vj,&dd);
       cout<<"0 1 dd="<<dd<<endl;

       gsl_matrix_get_row(vj, gms, 1);
       gsl_matrix_get_row(vi, gms, 2);
       gsl_blas_ddot(vi,vj,&dd);
       cout<<"1 2 dd="<<dd<<endl;

       gsl_matrix_get_row(vj, gms, 0);
       gsl_matrix_get_row(vi, gms, 2);
       gsl_blas_ddot(vi,vj,&dd);
       cout<<"0 2 dd="<<dd<<endl;
       */

    gsl_vector_free(vi);
    gsl_vector_free(vj);
}

//print the value of a vector
int showvector(gsl_vector* v)
{
    int i, n;
    n=v->size;

    for(i=0;i<n;i++)
    {
	cout<<gsl_vector_get(v,i)<<" ";
    }
    cout<<endl;
}


// print the values of a matrix
int showmatrix(gsl_matrix* m)
{

    int i, j, r, n;

    r=m->size1;
    n=m->size2;
    for (i=0;i<r;i++)
    {
	for(j=0;j<n;j++)
	{
	    cout<< gsl_matrix_get(m,i,j)<<" ";
	}
	cout<<endl;
    }
    return 0;
}

// find the optimal endmember set of a pixel at a given time by finding EM set resulted in minimum projection angle
// return the index number of em set and the projection angle
int findoptimalemset(vector<gsl_matrix*>& emsets, vector<gsl_matrix*>& og_emsets, int pnum, int pind, int tind, int band, float** data, int& em_ind, double& angle, vector<double>& rcoefs, vector<int>& rngind, vector<vector<int> >& comb_ind)
{
    int i, ss, pc, aindex, bem_ind;
    gsl_vector *vd;
    double* alist, *blist;
    vector<double> coefs;
    double bangle;

    string emname[]={"BS", "GV", "NPV", "WATER"};

    //   ss= emsets.size();
    ss=rngind[1]-rngind[0];
    alist = new double[rngind[1]-rngind[0]];
    blist = new double[rngind[1]-rngind[0]];

    vd=gsl_vector_alloc(band);
    for(i=0;i<band;i++)
    {
	pc=tind*pnum+pind;
	gsl_vector_set(vd, i, (double) data[i][pc] );
    }

    int cc=0;
    if (checkrgb(vd))
    {

	//   #pragma omp parallel private(i)  firstprivate(coefs) 
	//   #pragma omp for schedule(dynamic, 5) nowait
	//    #pragma omp for 
	for(i=rngind[0];i<rngind[1];i++)
	{
	    aindex=i-rngind[0];
	    em_projection(emsets[i], og_emsets[i], vd, coefs, alist[aindex]);
	    if (!allpositive(coefs))
	    {	
		alist[aindex]=9999;
	    }
	    if (comb_ind[i][3]!=-1)
	    {	
		blist[aindex]=9999;
	    }
	    else
	    {
		cc++;
		blist[aindex]=alist[aindex];
	    }

	}
	em_ind=gsl_stats_min_index(alist, 1, ss);
	angle=alist[em_ind];
	em_ind+=rngind[0];
	if (angle != 9999)
	{
	    em_projection(emsets[em_ind], og_emsets[em_ind], vd, coefs, angle);
	}
	else
	{
	    em_ind=-1;
	    angle = 3.14;
	    coefs.assign(3,0);
	}

    }
    else
    {
	em_ind = -2;
	angle = 2*3.14;
	coefs.assign(3,0);
    }
    /*
       cout<<"pixel index="<<pind<<endl;
       cout<<"with water EM, angle="<<angle<<" coefs.size()="<<coefs.size()<<" emindex="<<em_ind<<"   ";

       normalweight(coefs);
       cc=0;
       for(i=0;i<coefs.size();i++)
       {
       while(comb_ind[em_ind][cc]<0)
       {
       cc++;
       }
       cout<<emname[cc]<<": "<<coefs[i]<<" ";
       cc++;
       }
       cout<<endl;
       bem_ind=gsl_stats_min_index(blist, 1, ss);
       bangle=alist[bem_ind];
       bem_ind+=rngind[0];
       em_projection(emsets[bem_ind], og_emsets[bem_ind], vd, coefs, bangle);



       cout<<"without water EM, angle="<<bangle<<" coefs.size()="<<coefs.size()<<" emindex="<<bem_ind<<" improvement="<<(bangle-angle)/bangle*100<<"%"<<" ";
       normalweight(coefs);
       cc=0;
       for(i=0;i<coefs.size();i++)
       {
       while(comb_ind[bem_ind][cc]<0)
       {
       cc++;
       }
       cout<<emname[cc]<<": "<<coefs[i]<<" ";
       cc++;
       }
       cout<<endl;


    //   cout<<coefs[0]<<" "<<coefs[1]<<"  "<<coefs[2]<<"  "<<endl;
    */
    rcoefs=coefs;
    delete [] alist;
    delete [] blist;
    gsl_vector_free(vd);
}

// Project vector vd onto the subspace specified by vector set eml, return the projected vector in form of coefficients for the original vectors,
// the angle between  vd and the projected vector is put into angle, angle \in [0, pi] 
int em_projection(gsl_matrix* eml, gsl_matrix* oeml, gsl_vector* vd, vector<double>& coefs, double& angle)
{
    int i, r, n;
    gsl_vector *vi, *vb, *x, *tau, *res;
    gsl_matrix *HH;

    double dd, a1, a2;

    coefs.clear();
    r=eml->size1;
    n=eml->size2;

    vi=gsl_vector_alloc(r);
    vb=gsl_vector_alloc(r);
    x=gsl_vector_alloc(n);
    tau=gsl_vector_alloc(n);
    res=gsl_vector_alloc(r);
    HH=gsl_matrix_alloc(r,n);
    gsl_matrix_memcpy(HH, oeml);
    gsl_vector_set_zero(vb);


    for (i=0;i<n;i++)
    {
	gsl_matrix_get_col(vi, eml, i);
	gsl_blas_ddot(vi,vd,&dd);  // dd=<vi*vd>
	gsl_blas_daxpy(dd,vi,vb); // vb = dd*vi +vb
	//	coefs.push_back(dd);	
    }


    gsl_blas_ddot(vb,vd,&dd);
    a1= gsl_blas_dnrm2(vd);
    a2= gsl_blas_dnrm2(vb);

    if (a1*a2!=0)
    {
	angle = acos(dd/( a1* a2));
    }
    else
    {
	//	cout<<"error in projection. \n";
	angle=9999;
    }
    // cout<<"matrix"<<endl;
    // showmatrix(HH);
    // cout<<"vector"<<endl;
    // showvector(b);
    gsl_linalg_QR_decomp(HH, tau);
    gsl_linalg_QR_lssolve(HH, tau, vb, x, res);
    // cout<<"resultant vector"<<endl;
    // showvector(x);

    //   cout<<"residual vector"<<endl;
    //   showvector(res);

    //  gsl_vector_set_zero(res);


    for (i=0;i<n;i++)
    {
	coefs.push_back(gsl_vector_get(x, i));
	//	gsl_matrix_get_col(vi, oeml, i);
	//	gsl_blas_daxpy(coefs[i], vi, res);
    }

    //    cout<<"projected vector"<<endl;
    //    showvector(vb);
    //    cout<<"constructed vector"<<endl;
    //    showvector(res);

    //    gsl_vector_memcpy(res, vd);	
    //    gsl_blas_daxpy(-1, vb, res);
    //    gsl_blas_ddot(res, vb, &dd);
    //    cout<<"dd="<<dd<<endl;

    gsl_vector_free(vi);
    gsl_vector_free(vb);
    gsl_vector_free(x);
    gsl_vector_free(tau);
    gsl_vector_free(res);
    gsl_matrix_free(HH);

    return 0;
}

// Normalize elements in coefs, so that they sum to 1
int normalweight(vector<double>& coefs)
{
    int i,ss;
    double sum=0;
    ss = coefs.size();

    //  if (!allpositive(coefs))
    //  {
    //	cout<<"error!"<<endl;
    //  }
    for (i=0;i<ss;i++)
    {
	sum+=fabs(coefs[i]);
    }
    if (sum==0)
    {
	return -1;
    }
    for (i=0;i<ss;i++)
    {
	coefs[i]=fabs(coefs[i])/sum;
    }
}

// check if all elements in coefs are positive 
bool allpositive(vector<double>& coefs)
{
    int i, ss;
    ss=coefs.size();

    for(i=0;i<ss;i++)
    {
	if (coefs[i]<0)
	{
	    return false;
	}
    }

    return true;

}


// check B G R reflectance reading of vb, if they are not all zero, return true, otherwise, return false
bool checkrgb(gsl_vector* vb)
{
    int i;
    double sum=0;

    for(i=0;i<3;i++)
    {
	sum+=gsl_vector_get(vb,i);
    }
    if (sum==0)
    {
	return false;
    }
    else
    {
	return true;
    }

}


// checking if a particular band of data at a given time sequence , if they are not all zero, return true
// otherwise, return false
bool checkts(float** data, int band, int pnum, int tind)
{
    float mean=0;
    int i, p;
    p=pnum*tind;
    for(i=0;i<pnum;i++)
    {
	mean+=data[band][p+i];
    }
    if (mean==0)
    {
	return false;
    }
    else
    {
	return true;
    }
}

// Output a set a matrix to a file, it is assumed that the matrices will have identical dimensions, 
// The first line of the output file 
int outputemsets(const char* ofname, vector<gsl_matrix*>& msets)
{
    int i, j, k, ss, r, n;
    FILE* fp;

    ss=msets.size();
    if (ss==0)
    {
	cout<<"This is an empty set, no file is written.\n"<<endl;
	return -1;
    }

    fp=fopen(ofname, "wt");
    if (ofname==NULL)
    {
	cout<<"Unable to open output file.\n"<<endl;
	return -2;
    }

    fprintf(fp, "%d\n", ss);
    for (i=0;i<ss;i++)
    {
	r=msets[i]->size1;
	n=msets[i]->size2;
	fprintf(fp,"%d\t%d\t%d\n",i, r, n);
	for (j=0;j<r;j++)
	{
	    for(k=0;k<n;k++)
	    {
		fprintf(fp, "%f\t", gsl_matrix_get(msets[i], j, k));	    
	    }
	    fprintf(fp,"\n");
	}
    }
    fclose(fp);
}

// output a vector of integer to a file, the items will be separated by character det,  
// each line consists of n items, if n<0, there will be no line break in the file.
int outputvector(const char* ofname, vector<int>& msets, char det, int n)
{
    int i, ss;
    ofstream fout;

    ss=msets.size();
    if (ss==0)
    {
	cout<<"This is an empty set, no file is written.\n"<<endl;
	return -1;
    }

    fout.open(ofname);
    if (!fout.good())
    {
	cout<<"Unable to open output file.\n"<<endl;
	return -2;
    }

    for (i=0;i<ss;i++)
    {
	fout<<msets[i]<<det;
	if (n>0)
	{
	    if (i>0 && i%n==0)
	    {
		fout<<endl;
	    }
	}
    }
    fout.close();
}


// Reading data from a binary file, the length of the header is specified in h, the content of header and data is put into header and data
// sf is the size of the specify data type, if the files stores double data, set sf=sizeof(double), if it is float, set sf=sizeof(float)
int readbinfile(const char* ifname, double*& data, double*& header, int h)
{
    ifstream fin;
    int pnum, ss, sf, dnum;	

    fin.open(ifname, ios::binary|ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file.\n";
	return -2;
    }
    else
    {
	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }


    fin.seekg(0, ios::end);
    ss=fin.tellg();
    fin.clear();
    fin.seekg(ios::beg);

    sf=sizeof(double);
    if (h>0)
    {	
	header=new double[h];
	dnum=ss/sf-h;
    }
    else
    {
	dnum=ss/sf;
    }
    data=new double[dnum];
    if (h>0)
    {
	fin.read((char*)header, h*sf);
    }
    fin.read((char*)data, ss-h*sf);

    fin.close();
    return dnum;
}

int readbinfile_int(const char* ifname, int*& data, int*& header, int h)
{
    ifstream fin;
    int pnum, ss, sf, dnum;	

    fin.open(ifname, ios::binary|ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file.\n";
	return -2;
    }
    else
    {
	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }


    fin.seekg(0, ios::end);
    ss=fin.tellg();
    fin.clear();
    fin.seekg(ios::beg);

    sf=sizeof(int);
    if (h>0)
    {	
	header=new int[h];
	dnum=ss/sf-h;
    }
    else
    {
	dnum=ss/sf;
    }
    data=new int[dnum];
    if (h>0)
    {
	fin.read((char*)header, h*sf);
    }
    fin.read((char*)data, ss-h*sf);

    fin.close();

    return dnum;
}

int readbinfile_short(const char* ifname,  short*& data,  short*& header, int h)
{
    ifstream fin;
    int pnum, ss, sf, dnum;	

    fin.open(ifname, ios::binary|ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file.\n";
	return -2;
    }
    else
    {
	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }


    fin.seekg(0, ios::end);
    ss=fin.tellg();
    fin.clear();
    fin.seekg(ios::beg);
    
    sf=sizeof(short);
    if (h>0)
    {	
	header=new  short[h];
	dnum=ss/sf-h;
    }
    else
    {
	dnum=ss/sf;
    }
    data=new  short[dnum];
    if (h>0)
    {
	fin.read((char*)header, h*sf);
    }
    fin.read((char*)data, ss-h*sf);
    
    fin.close();

    return dnum;
}

int readbinfile_float(const char* ifname, float*& data, float*& header, int h)
{
    ifstream fin;
    int pnum, ss, sf, dnum;	

    fin.open(ifname, ios::binary|ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file.\n";
	return -2;
    }
    else
    {
	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }


    fin.seekg(0, ios::end);
    ss=fin.tellg();
    fin.clear();
    fin.seekg(ios::beg);

    sf=sizeof(float);
    if (h>0)
    {	
	header=new float[h];
	dnum=ss/sf-h;
    }
    else
    {
	dnum=ss/sf;
    }
    data=new float[dnum];
    if (h>0)
    {
	fin.read((char*)header, h*sf);
    }
    fin.read((char*)data, ss-h*sf);
    fin.close();
    return dnum;
}
int readbinfile_char(const char* ifname, char*& data, char*& header, int h)
{
    ifstream fin;
    int pnum, ss, sf, dnum;	

    fin.open(ifname, ios::binary|ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file.\n";
	return -2;
    }
    else
    {
	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }


    fin.seekg(0, ios::end);
    ss=fin.tellg();
    fin.clear();
    fin.seekg(ios::beg);

    sf=sizeof(char);
    if (h>0)
    {	
	header=new char[h];
	dnum=ss/sf-h;
    }
    else
    {
	dnum=ss/sf;
    }
    data=new char[dnum];
    if (h>0)
    {
	fin.read((char*)header, h*sf);
    }
    fin.read((char*)data, ss-h*sf);

    fin.close();
    return dnum;
}


// sort combination of EM sets in order of number of EMs in the combinations, return the index when the number of EMs change
//
int sort_comb(vector< vector<int> >& comb, vector <int>& cind)
{
    int i, ss, wd, j, cc;
    vector< vector<int> > dind, pcomb;
    vector<int>   cpse;

    ss=comb.size();

    if (ss==0)
    {
	return -1;
    }
    wd=comb[0].size();
    dind.assign(wd, cpse);
    cind.clear();

    for(i=0;i<ss;i++)
    {
	dind[comb[i][wd-1]].push_back(i);
    }

    cc=0;
    for(i=0;i<wd;i++)
    {
	ss=dind[i].size();
	cind.push_back(cc);
	for(j=0;j<ss;j++)
	{
	    pcomb.push_back(comb[dind[i][j]]);
	    cc++;
	}
    }
    comb=pcomb;
}

// output a vector of vector of integer to a file, the items will be separated by character det,  
// each line consists of all items from a vector of integer
int outputvectorvector(const char* ofname, vector< vector<int> >& msets, char det)
{
    int i, ss, vv, j;
    ofstream fout;

    ss=msets.size();

    if (ss==0)
    {
	cout<<"This is an empty set, no file is written.\n"<<endl;
	return -1;
    }

    fout.open(ofname);
    if (!fout.good())
    {
	cout<<"Unable to open output file.\n"<<endl;
	return -2;
    }

    for (i=0;i<ss;i++)
    {
	fout<<i<<endl;
	vv=msets[i].size();
	if (vv>0)
	{
	    for(j=0;j<vv;j++)
	    {
		fout<<msets[i][j]<<det;
	    }
	}
	fout<<endl;
    }
    fout.close();
}

// Find the first line which containing a specific marker in a text file 
//
int findmarker(ifstream& fin, string marker, string& st, int hits)
{
    char buf[10*1024];
    int found, cc;
    cc=0;
    do 
    {
	fin.getline(buf, 1024*10, '\n');
	if (fin.eof())
	{
	    return -1;
	}
	st=buf;
	found=st.find(marker);
	if (found!=string::npos)
	{
	    cc++;
	}
	if (cc==hits)
	{
	    return found;
	}
    }while(!fin.eof());
    return -1;
}

// Find the maximum value of a list specified band from a time series
// data - time series of all bands
// mdata - store the results, the mdata will have identical number of band as data, the number of time series of mdata will be equivalent to 
// the number of bands specified by maxind
// pnum - the number of pixels
// ts - the number of time series
// band - the number of band
// maxind - a list of the index of band which the maximum value in the time series will be found


int findmdata(float** data, float**& mdata, int pnum, int ts, int band, vector<int>& maxind)
{
    int i, j, ss, tind, pind, pkd, pc, ppc;
    float peak;


    mdata  = new float* [band];
    ss=maxind.size();
    for (i=0;i<band;i++)
    {
	mdata[i] = new float[pnum*ss];
    }


    for(i=0;i<ss;i++)
    {
	for(pind=0;pind<pnum;pind++)
	{
	    peak=-1;
	    pkd=-1;
	    for (tind=0;tind<ts;tind++)
	    {
		pc=tind*pnum+pind;
		if (data[maxind[i]][pc]>peak)
		{
		    pkd=tind;
		    peak=data[maxind[i]][pc];
		}
	    }
	    pc=i*pnum+pind;
	    ppc=pkd*pnum+pind;
	    for(j=0;j<band;j++)
	    {
		mdata[j][pc]=data[j][ppc];
	    }
	}
    }

    return 0; 
}



int findallexterme(float** data, float** mdata, int pnum, int ts)
{
    int i, j, ss, tind, pind, pkd, pc, cc_sr, cc_cai;
    int  srmax_ind, caimax_ind, scmin_ind, b5min_ind;
    float srmax, caimax, scmin, b5min, srmin, caimin, srmean, caimean;


    // #pragma omp parallel private( i, j, ss, tind, pind, pkd, pc, ppc, srmax_ind, caimax_ind, scmin_ind, b5min_ind, srmax, caimax, scmin, b5min) firstprivate(pnum, ts)  
    //    #pragma omp for schedule(dynamic, 10) nowait
    for(pind=0;pind<pnum;pind++)
    {
	srmax=-1;
	caimax=-1;
	scmin=9999;
	b5min=9999;
	srmin=9999;
	caimin=9999;
	srmean=0;
	caimean=0;

	srmax_ind=0;
	caimax_ind =0; 
	scmin_ind=0;
	b5min_ind=0;
	cc_sr=0;
	cc_cai=0;
	for (tind=0;tind<ts;tind++)
	{
	    pc=tind*pnum+pind;

	    if (data[7][pc]>srmax && data[7][pc]>0)
	    {
		srmax_ind=tind;
		srmax=data[7][pc];
	    }
	    if (data[7][pc]<srmin && data[7][pc]>0)
	    {
		srmin=data[7][pc];
	    }
	    if (data[7][pc]>0)
	    {
		srmean+=data[7][pc];
		cc_sr++;
	    }

	    if (data[6][pc]>caimax && data[6][pc]>0)
	    {
		caimax_ind=tind;
		caimax=data[6][pc];
	    }
	    if (data[6][pc]<caimin && data[6][pc]>0)
	    {
		caimin=data[6][pc];
	    }
	    if (data[6][pc]>0)
	    {
		caimean+=data[6][pc];
		cc_cai++;
	    }

	    if ((data[6][pc]+data[7][pc])<scmin && (data[6][pc]+data[7][pc])>0)
	    {
		scmin_ind=tind;
		scmin=data[6][pc]+data[7][pc];
	    }
	    if (data[4][pc]<b5min && data[4][pc]>0)
	    {
		b5min_ind=tind;
		b5min=data[4][pc];
	    }
	}

	if (pnum-pind<10)
	{
	    cout<<srmax_ind<<" ";
	    cout<<caimax_ind<<" ";
	    cout<<scmin_ind<<" ";
	    cout<<b5min_ind<<" ";
	    cout<<endl;

	}

	for(i=0;i<4;i++)
	{
	    if (i==0)
	    {
		mdata[i*8+6][pind]=srmax;
		mdata[i*8+7][pind]=srmax_ind;
		tind=srmax_ind;
	    }
	    else if (i==1)
	    {
		mdata[i*8+6][pind]=caimax;
		mdata[i*8+7][pind]=caimax_ind;
		tind=caimax_ind;
	    }
	    else if (i==2)
	    {
		mdata[i*8+6][pind]=scmin;
		mdata[i*8+7][pind]=scmin_ind;
		tind=scmin_ind;
	    }
	    else if (i==3)
	    {
		mdata[i*8+6][pind]=b5min;
		mdata[i*8+7][pind]=b5min_ind;
		tind=b5min_ind;
	    }
	    for(j=0;j<6;j++)
	    {
		mdata[i*8+j][pind]=data[j][tind*pnum+pind];
	    }
	}
	if (cc_sr!=0)
	{
	    mdata[34][pind]=srmin;
	    mdata[35][pind]=srmean/cc_sr;
	    mdata[36][pind]=srmax/srmin;
	}
	else
	{
	    mdata[34][pind]=-1;
	    mdata[35][pind]=-1;
	    mdata[36][pind]=-1;
	}

	if (cc_cai!=0)
	{    
	    mdata[37][pind]=caimin;
	    mdata[38][pind]=caimean/cc_cai;
	    mdata[39][pind]=caimax/caimin;
	}
	else
	{

	    mdata[37][pind]=-1;
	    mdata[38][pind]=-1;
	    mdata[39][pind]=-1;
	}



    }

    return 0;
}

// output an array of data into a text file, the number of columns is set in icol, the 
// data is delimited by character det, 
// total -- the total number of the data
int writetxtfile_float(ofstream& fout, float* data, char det, int icol, int total, int offs)
{
    int i;

    for (i=0;i<total;i++)
    {
	fout<<data[i];
	if ((i+1+offs)%icol==0)
	{
	    fout<<"\n";	    
	}
	else
	{
	    fout<<det;	    
	}
    }
    return 0;
}

// output an array of data into a text file, the number of columns is set in icol, the 
// data is delimited by character det, 
// total -- the total number of the data
int writetxtfile_double(ofstream& fout, double* data, char det, int icol, int total, int offs)
{
    int i;

    for (i=0;i<total;i++)
    {
	fout<<data[i];
	if ((i+1+offs)%icol==0)
	{
	    fout<<"\n";	    
	}
	else
	{
	    fout<<det;	    
	}
    }
    return 0;
}

// Read a block of data from a (Time series) image file
// The procedure will read k blocks of data from fin into array data
// pos - the number of blocks offset from beginning of the fin
int readimg(ifstream& fin, float*& data, int pnum, int pos, int k)
{
    int i, j, sf, len;
    sf = sizeof(float);

    fin.seekg(0,ios::end);
    len=fin.tellg();
    if (len<(pnum*pos*sf+pnum*k*sf))
    {
	cout<<"The specified read length is longer than the file size.\n";
	return -1;
    }
    data  = new float[pnum*k];
    fin.seekg( pnum*pos*sf, ios::beg);

    fin.read((char*)data, pnum*k*sf);
    return 0;
}

// Output a envi header file
int writeenviheader(string ofname, string des, int samples, int lines, int bands, int datatype, string interleave, 
	int xstart, int ystart, string mapinfo,  string wavelengthunit, vector<string>& bandnames, string projection_info, string coor_string)
{
    int i, ss, ivd;    
    ofstream fout;

    fout.open(ofname.c_str());
    if (fout.good())
    {

	cout<<"Successfully open output file "<<ofname<<endl;
    }
    else
    {
	cout<<"Fail to open output file "<<ofname<<endl;
	return -1;
    }

    ivd=-9999;

    fout<<"ENVI"<<endl;
    fout<<"description =  { "<<des<<" }"<<endl;
    if (samples!=ivd)
    {
	fout<<"samples = "<<samples<<endl;
    }
    if (lines!=ivd)
    {
	fout<<"lines   = "<<lines  <<endl;
    }

    if (bands!=ivd)
    {
	fout<<"bands   = "<<bands  <<endl;
    }

    fout<<"header offset = 0"<<endl;
    fout<<"file type = ENVI Standard"<<endl;
    

    if (datatype!=ivd)
    {
	fout<<"data type = "<<datatype<<endl;
    }
    fout<<"interleave = "<<interleave<<endl;
    fout<<"sensor type = Unknown"<<endl;
    
    fout<<"byte order = 0"<<endl;
    if (xstart!=ivd)
    {
	fout<<"x start = "<<xstart<<endl;
    }
    if (ystart!=ivd)
    {
	fout<<"y start = "<<ystart<<endl;
    }
    fout<<"map info =  {"<<mapinfo<<"}"<<endl;
    fout<<"projection info = "<<projection_info<<endl;
    fout<<"coordinate system string = "<<coor_string<<endl;

    fout<<"wavelength units = "<<wavelengthunit<<endl;
    fout<<"band names = { "<<endl;

    ss=bandnames.size();
    for(i=0;i<ss;i++)
    {
//	fout<<"\""<<bandnames[i]<<"\"";
	fout<<bandnames[i];
	if (i<ss-1)
	{
	    fout<<",";
	}
	fout<<endl;
    }
    fout<<"}"<<endl;


}



// Output a envi header file
int writeenviheader(string ofname, string des, int samples, int lines, int bands, int datatype, string interleave, 
	int xstart, int ystart, string mapinfo,  string wavelengthunit, vector<string>& bandnames)
{
    int i, ss, ivd;    
    ofstream fout;

    fout.open(ofname.c_str());
    if (fout.good())
    {

	cout<<"Successfully open output file "<<ofname<<endl;
    }
    else
    {
	cout<<"Fail to open output file "<<ofname<<endl;
	return -1;
    }

    ivd=-9999;

    fout<<"ENVI"<<endl;
    fout<<"description =  { "<<des<<" }"<<endl;
    if (samples!=ivd)
    {
	fout<<"samples = "<<samples<<endl;
    }
    if (lines!=ivd)
    {
	fout<<"lines   = "<<lines  <<endl;
    }

    if (bands!=ivd)
    {
	fout<<"bands   = "<<bands  <<endl;
    }

    fout<<"header offset = 0"<<endl;
    fout<<"file type = ENVI Standard"<<endl;
    

    if (datatype!=ivd)
    {
	fout<<"data type = "<<datatype<<endl;
    }
    fout<<"interleave = "<<interleave<<endl;
    fout<<"sensor type = Unknown"<<endl;
    
    fout<<"byte order = 0"<<endl;
    if (xstart!=ivd)
    {
	fout<<"x start = "<<xstart<<endl;
    }
    if (ystart!=ivd)
    {
	fout<<"y start = "<<ystart<<endl;
    }
    fout<<"map info =  {"<<mapinfo<<"}"<<endl;



    fout<<"wavelength units = "<<wavelengthunit<<endl;
    fout<<"band names = { "<<endl;

    ss=bandnames.size();
    for(i=0;i<ss;i++)
    {
//	fout<<"\""<<bandnames[i]<<"\"";
	fout<<bandnames[i];
	if (i<ss-1)
	{
	    fout<<",";
	}
	fout<<endl;
    }
    fout<<"}"<<endl;


}

// allocate memory to an cone object
cone* createcone(cone*& onecone, int band, int* cndind, float** data)
{   int i, ind, signum,j;
    bool flag;
    flag=false;
    onecone=new cone;
    onecone->_A = gsl_matrix_alloc(band,band);
    for(i=0;i<band;i++) 
    {
	ind=cndind[i];
	for(j=0;j<band;j++)
	{
	    if (data[j][ind]!=0)
	    {
		gsl_matrix_set(onecone->_A, j, i, data[j][ind]);
	    }
	    else
	    {
		flag=true;
		break;
	    }
	}
	if (flag)
	{
	    break;
	}
    }
    if (flag)
    {
	gsl_matrix_free(onecone->_A);
	delete onecone;
	onecone=NULL;

    }
    else
    {
	onecone->_LU = gsl_matrix_alloc(band,band);
	gsl_matrix_memcpy(onecone->_LU, onecone->_A);
	onecone->_p=gsl_permutation_alloc(band);
	gsl_linalg_LU_decomp(onecone->_LU, onecone->_p, &signum);
	if (gsl_linalg_LU_det(onecone->_LU, signum)==0)	
	{
	    gsl_matrix_free(onecone->_A);
	    gsl_matrix_free(onecone->_LU);
	    gsl_permutation_free(onecone->_p);
	    delete onecone;
	    onecone=NULL;
	}
	else
	{
	    onecone->_x = gsl_vector_alloc(band);
	    onecone->_index=new int[band];
	    for (i=0;i<band;i++)
	    {
		onecone->_index[i]=cndind[i];
	    }
	}
    }


    return onecone;
}

// release memory and objects allocated to an cone object
int deletecone(cone*& onecone)
{
    gsl_matrix_free(onecone->_A);
    gsl_matrix_free(onecone->_LU);
    gsl_vector_free(onecone->_x);
    gsl_permutation_free(onecone->_p);
    delete [] onecone->_index;
    delete onecone;
    onecone=NULL;
    return 0;
}


int emfind_onepixel(float** data, int ind, int band, cone** S, int *slist, bool* F,
	double* pos, double* zero, double* neg, size_t* sortindexs, int* cndind,  int& ptr_S, 
	vector<int>* ptoem, int& ptr_pto)
{
    int i, ss, cdi, rdi, j, k, vv, offs, bs, bcc, r1, r2, em_ind, act, cc;
    //  double *pos, *neg, *zero;
    //  size_t* sortindexs;
    //  int* cndind;
    double m;

    bool    sw_flag, sp_flag;
    cone* onecone, *newcone;
    gsl_vector* b;


    ss=ptr_S;
    b=gsl_vector_alloc(band);
    //   cndind=new int[band];
    //   pos=new double[ss];
    //   neg=new double[ss];
    //   zero=new double[ss];
    //   sortindexs=new size_t[ss];
    for(i=0;i<band;i++)
    {
	gsl_vector_set(b, i, (double)data[i][ind]);
    }


#pragma omp parallel private(i) firstprivate(ss)  
#pragma omp for schedule(dynamic, 10) nowait
    for(i=0;i<ss;i++)
    {
	pos[i]=0;
	neg[i]=0;
	zero[i]=0;
    }

    bs=1000;
    bcc=(int)floor((ss-1.0)/bs)+1 ;
    for(k=bcc;k>0;k--)
    {
	r2=k*bs;
	if (r2>ss)
	{
	    r2=ss;
	}
	r1=(k-1)*bs;
#pragma omp parallel private(i, j, m, onecone) firstprivate(ss, band, b, r1, r2)  
#pragma omp for schedule(dynamic, 20) nowait
	for(i=r1;i<r2;i++)
	    //	for(i=0;i<ss;i++)
	{
	    //pos[i]=0;
	    //neg[i]=0;
	    onecone=S[i];
	    gsl_vector_memcpy(onecone->_x, b);	
	    gsl_linalg_LU_svx(onecone->_LU, onecone->_p, onecone->_x);	
	    for(j=0;j<band;j++)
	    {
		m=gsl_vector_get(onecone->_x, j);
		if (m>0)
		{
		    pos[i]++;
		}
		else if (m==0)
		{
		    zero[i]++;
		}
		else if (m<0)
		{
		    neg[i]++;
		}
	    }
	}
	sw_flag=false;
	sp_flag=false;

	//	if (!sp_flag)
	//	{
	for(i=r1;i<r2;i++)
	{
	    if (pos[i]==1 && neg[i]>0 && zero[i]==0)
	    {
		onecone=S[i];
		for(j=0;j<band;j++)
		{
		    m=gsl_vector_get(onecone->_x, j);
		    if (m>0)
		    {
			break;
		    }
		}
		rdi=onecone->_index[j];  // this is the vector to be replaced by vector ind
		reponevector(rdi, ind, band, S, i,  slist, F, data, ptoem, ptr_pto);
		sw_flag=true;
		act=1;
		break;
	    }
	}

	//	}
	if (!sw_flag)
	{
	    for(i=r1;i<r2;i++)
	    {
		if ((pos[i]+zero[i])==band)
		{
		    // add codes to check the situation that the vector is spanned by multiple cones
		    slist[ind]=i;  //
		    sp_flag=true;
		    act=2;
		    //	cout<<"P#="<<ind<<" spanned by H#="<<i<<endl;
		    break;
		}
	    }
	}

	if (sp_flag || sw_flag)
	{
	    break;
	}
    }
    if (!sw_flag && !sp_flag)  // Create new hulls with 
    {
	gsl_sort_index(sortindexs, neg, 1, ss);
	cdi=sortindexs[0];
	onecone=S[cdi];
	F[ind]=true;
	cc=0;
	slist[ind]=ptr_pto;
	ptr_pto++;
	for(j=0;j<band;j++)
	{
	    m=gsl_vector_get(onecone->_x, j);
	    if (m<0)
	    {
		rdi=onecone->_index[j];
		for(k=0;k<band;k++)
		{
		    cndind[k]=onecone->_index[k];
		}
		cndind[j]=ind;
		/*
		   for(k=0;k<band;k++)
		   {
		   cout<<cndind[k]<<" ";
		   }
		   cout<<endl;
		   */
		createcone(newcone,  band,  cndind,  data);
		//		cout<<"neg#="<<neg[cdi]<<" cc="<<cc<<" ptr_S="<< ptr_S<<"  ind="<<ind<<" ptr_pto="<<ptr_pto<<endl;
		for(k=0;k<band;k++)
		{
		    vv=cndind[k];
		    ptoem[slist[vv]].push_back(ptr_S);
		}
		S[ptr_S]=newcone;
		ptr_S++;
		cc++;
		//break;
	    }
	}

	//	cout<<"neg#="<<neg[cdi]<<" cc="<<cc<<" ptr_S="<< ptr_S<<"  ind="<<ind<<endl;
	act=3;
    }
    gsl_vector_free(b);

    //  delete [] cndind;
    //  delete [] pos;
    //  delete [] neg;
    //   delete [] zero;
    //  delete [] sortindexs;
    return act-1;
}

// replace vector (of index rdi) with vector (of index cdi) in every cone* involving vector of index rdi
int reponevector(int rdi, int ind, int band, cone** S, int cdi, int* slist, bool* F, float** data,
	vector<int>* ptoem, int& ptr_pto)
{
    int i, ss,  j, k, signum, ppt, vv;
    int* cndind;
    bool flag;
    cone* onecone;

    vv=slist[rdi];   // The index of ptoem which point to a list of hull which vector rdi is involved
    slist[ind]=vv; // The hull spanned by hulls involved with vector rdi is now all invloved with vector ind

    F[ind]=true;
    if (F[rdi])
    {
	F[rdi]=false;
    }
    else
    {
	cout<<"Negative F[i]"<<endl;
    }

    ss=ptoem[vv].size();
    //  cout<<"P#="<<rdi<<" replaced by P#"<<ind<<" ss="<<ss<<" vv="<<vv;
    for(i=0;i<ss;i++)
    {
	ppt=ptoem[vv][i];
	//	cout<<" H"<<i<<"#="<<ppt;
	onecone=S[ppt];
	flag=false;
	for(j=0;j<band;j++)
	{
	    if ( onecone->_index[j] == rdi)
	    {
		onecone->_index[j]=ind;
		for (k=0;k<band;k++)
		{
		    gsl_matrix_set(onecone->_A, k, j, (double)data[k][ind]);
		}
		gsl_matrix_memcpy(onecone->_LU, onecone->_A);
		gsl_linalg_LU_decomp(onecone->_LU, onecone->_p, &signum);
		flag=true;
		break;
	    }
	}
	if (!flag)
	{
	    cout<<"Error in reponevector. ind="<<ind<<" rdi="<<rdi<<" ss="<<ss<<" ppt="<<ppt<<" vv="<<vv<<endl;
	}
    }
    //   cout<<endl;
    slist[rdi]=cdi;  // vector rdi is now spanned by hull cdi

}


double pj_angle(float* vb, float* vd, int band)
{
    int i;
    double nb, nd, dp, angle;

    nb=0;
    nd=0;
    dp=0;

    for(i=0;i<band;i++)
    {
	nb+=vb[i]*vb[i];	
	nd+=vd[i]*vd[i];	
	dp+=vb[i]*vd[i];
    }	
    angle=acos(dp/(sqrt(nb)*sqrt(nd)));
    return angle;
}

// Classify a pixel, put it into one of the following four EM: BS, GV, NPV, WATER
int classifyem(float** data, int ind)
{
    int i, j;
    i = ind;
    if (data[5][i]<0.1 && data[4][i]<0.1) // WATER
    {
	j=3;
    }
    else if (data[3][i]/data[2][i]>4) //GV
    {
	j=1;
    }
    else if (data[5][i]/data[4][i]>0.8) // BS
    {
	j=0;
    }
    else if (data[5][i]/data[4][i]<0.8) // BS
    {
	j=2;
    }


    return j;
}



// Classify a pixel, put it into one of the following four EM: BS, GV, NPV, WATER, 
// using the results from MML decision graph program
int classifyem_v3(float* data, string& lab)
{
    int  j;
    float b75, b43, b52;
    if (data[1]>0)
    {
	b52=data[4]/data[1];
    }
    else
    {
	b52=-1;
    }
    if (data[2]>0)
    {
	b43=data[3]/data[2];
    }
    else
    {
	b43=-1;
    }
    if (data[4]>0)
    {
	b75=data[5]/data[4];
    }
    else
    {
	b75=-1;
    }

    if (b52<1.62089)
    {
	if (b43<1.29689)
	{
	    if (b52<0.644409)
	    {
		if (data[5]<0.0301957)
		{
		    j=4;
		    lab="water";
		}
		else
		{
		    if (b75<1.27611)
		    {
			j=8;
			lab="unknown";
		    }
		    else
		    {
			j=5;
			lab="Shade";
		    }

		}
	    }
	    else
	    {
		j=9;
		lab="clouds";
	    }
	}
	else
	{
	    if (b75<0)
	    {
		j=6;
		lab="bad data";
	    }
	    else
	    {
		j=5;
		lab="shade";
	    }

	}
    }
    else
    {
	if (b43<3.35751)
	{
	    if (b75<0.800007)
	    {	
		if (b75<0.554137)
		{
		    if (data[5]<0.0877083)
		    {
			j=6;
			lab="bad data";
		    }
		    else
		    {
			j=2;
			lab="GV wv";
		    }
		}
		else
		{
		    j=3;
		    lab="NPV";
		}

	    }
	    else
	    {
		j=0;
		lab="bare soil";
	    }
	}
	else
	{
	    if (b43<11.3943)
	    {
		j=2;
		lab="GV wv";
	    }
	    else
	    {
		j=1;
		lab="GV crop";
	    }

	}
    }
    return j;
}


// Classify a pixel, put it into one of the following four EM: BS, GV, NPV, WATER
int classifyem_v2(float* data, string& lab)
{

    int i, j, nms;
    float b75, b43, b52, b1, b2, b3, b4, b5, b7;
    double *vote;

    nms=3;

    vote = new double[nms];

    for(i=0;i<nms;i++)
    {
	vote[i]=0;
    }

    b1=data[0];
    b2=data[1];
    b3=data[2];
    b4=data[3];
    b5=data[4];
    b7=data[5];

    b75=b7/b5;
    b43=b4/b3;
    b52=b5/b2;

    if (b43<4.03028)
    {
	if (b5<0.203377)
	{
	    j=0;
	}
	else
	{
	    if (b75<0.889284)
	    {
		j=2;
	    }
	    else
	    {
		j=0;
	    }
	}

    }
    else
    {
	j=1;
    }

    vote[j]++;
    vote[j]++;

    if (b75<0.835149)
    {
	if (b1<0.03072  )
	{
	    j=1;
	}
	else
	{
	    j=2;
	}

    }
    else
    {
	j=0;
    }

    vote[j]++;

    if (b43>1.80525)
    {
	j=1;
    }
    else
    {

	if (b75<=0.834362)
	{
	    j=2;
	}
	else
	{

	    if ( b75<=0.864825 )
	    {
		if (b3<=0.090108 )
		{
		    j=0;
		}
		else
		{
		    j=2;
		}

	    }
	    else
	    {
		if (b5<=0.517497)
		{
		    j=0;	    
		}
		else
		{
		    if (b52<2.88172  )
		    {
			j=0;
		    }
		    else
		    {   
			j=2;
		    }

		}

	    }
	}

    }
    vote[j]++;

    j=classifyem_v1(data, lab);
    vote[j]++;


    j=gsl_stats_max_index(vote, 1, nms);
    if (j==0)
    {
	lab="BS";
    }
    else if (j==1)
    {
	lab="GV";
    }
    else if (j==2)
    {
	lab="NPV";
    }



    delete [] vote;
    return j;
}




// Classify a pixel, put it into one of the following four EM: BS, GV, NPV, WATER
int classifyem_v1(float* data, string& lab)
{
    int  j;
    if (data[5]<0.01 && data[4]<0.01) // WATER
    {
	j=3;
	lab="Water";
    }
    else if (data[3]/data[2]>4) //GV
    {
	j=1;
	if (data[3]/data[2]>11)
	{
	    lab="GV Crop";
	}
	else
	{
	    lab="GV Wv";
	}
    }
    else if (data[5]>0 && data[4]==0) // BS
    {
	j=0;
	lab="Bare Soil";
    }
    else if (data[5]/data[4]>0.8) // BS
    {
	j=0;
	lab="Bare Soil";
    }
    else if (data[5]/data[4]<0.8) // NPV
    {
	j=2;
	lab="NPV";
    }

    return j;
}


int pivot(double**& a, double**& b, int i, int j, int m, int n)
{
    int h, k;

    double  **buf;


    for (h=0;h<m;h++)
    {
	for(k=0;k<n;k++)
	{
	    if (i==h && j==k)
	    {
		b[h][k]=1/a[h][k];
	    }
	    else if (k==j && h!=i)
	    {
		b[h][j]=-a[h][j]/a[i][j];
	    }
	    else if (h==i && k!=j)
	    {
		b[i][k]=a[i][k]/a[i][j];
	    }
	    else
	    {	
		b[h][k]=a[h][k]-a[i][k]*a[h][j]/a[i][j];
	    }
	}
    }

    buf=a;
    a=b;
    b=buf;

    /*
       for (h=0;h<m;h++)
       {
       for(k=0;k<n;k++)
       {
       if (i==h && j==k)
       {
       b[h][k]=1/a[h][k];
       }
       else if (k==j && h!=i)
       {
       b[h][j]=-a[h][j]/a[i][j];
       }
       else if (h==i && k!=j)
       {
       b[i][k]=a[i][k]/a[i][j];
       }
       else
       {	
       b[h][k]=a[h][k]-a[i][k]*a[h][j]/a[i][j];
       }
       }
       }
       for (h=0;h<m;h++)
       {
       for(k=0;k<n;k++)
       {
       a[h][k]=b[h][k];
       }
       }
       */
}


// Solve a standard minimum linear programming problem
int standardlpmin(double**& a, double**& b, int* mf, int m, int* nf, int n)
{
    int rs, i, j, h, k;	

    i=0;
    do
    {
	i++;
	if (i>10000)  // Break death locks
	{
	    cout<<"One deadlock"<<endl;
	    return -9999;
	}
	rs=onepivot(a, b, mf, m, nf, n);
    }
    while(rs==0);

    return rs;
}

int onepivot(double**& a, double**& b, int* mf, int m, int* nf, int n)
{
    int i, j, mind, tmp;
    float minra, ra;
    bool cflag, bflag;


    bflag=true;
    cflag=true;
    for(j=0;j<n-1;j++)
    {	
	if (a[m-1][j]<0)
	{
	    cflag=false;
	    break;
	}
    }
    if (cflag)   // case 1, all c_i >0
    {
	for(i=0;i<m-1;i++)
	{
	    if (a[i][n-1]<0 && mf[i]!=-2)
		//	if (a[i][n-1]<0 && mf[i]>=0)
	    {
		bflag=false;
		mind=-1;
		minra=-1;
		for(j=0;j<n-1;j++)
		{
		    if (a[i][j]<0)
		    {
			ra=fabs(a[m-1][j]/a[i][j]);       
			if (minra<0 || ra<minra)
			{
			    minra=ra;
			    mind=j;
			}
		    }
		}
		if (minra!=-1)
		{
		    //  cout<<"("<<i<<", "<<mind<<") is pivot"<<endl;
		    tmp=mf[i];
		    mf[i]=nf[mind];
		    nf[mind]=tmp;
		    pivot(a, b, i, mind, m, n);
		    return 0; // Need further pivot operation
		}
	    }
	}
	if (bflag)
	{
	    // cout<<"We found a solution."<<endl;
	    return 1;   // we may have found a solution
	}
	else
	{
	    return -9999;  // There are unbounded feasible solution
	}
    }
    else
    {
	mind=-1;
	minra=-1;
	for(i=0;i<m-1;i++)
	{
	    if (a[i][j]>0 && mf[i]!=-2)
		//if (a[i][j]>0 && mf[i]>=0)
	    {
		ra=fabs(a[m-1][j]/a[i][j]);       
		if (minra<0 || ra<minra)
		{
		    minra=ra;
		    mind=i;
		}
	    }
	}
	if (mind!=-1)
	{
	    //cout<<"("<<mind<<", "<<j<<") is pivot"<<endl;
	    tmp=mf[mind];
	    mf[mind]=nf[j];
	    nf[j]=tmp;
	    pivot(a, b, mind, j, m, n);
	    return 0;  // Need further pivot operation
	}
	else
	{
	    return -1; // There is no feasible solution for this problem
	}
    }
}


// Generate a random vector whose sum of its elements >= lob and <= upb
int gensimplex(gsl_rng* rng, double lob, double upb, double* pr, int s)
{
    int i;
    double* u; 
    size_t* sts;
    sts=new size_t[s];
    u =new double[s];

    do
    {
	for(i=0;i<s;i++)
	{
	    u[i]=gsl_rng_uniform(rng)*upb;
	}
	gsl_sort(u, 1, s);
    }while (u[s-1]<lob || u[s-1]>upb);
    for(i=0;i<s;i++)
    {
	if (i==0)
	{
	    pr[i]=u[i];
	}
	else
	{
	    pr[i]=u[i]-u[i-1];
	}
    }
    delete [] sts;
    delete [] u;
}


// copy row x col content from a matrix (or part of a matrix, which can be larger than row x col)
int msacpy(double** des, double** src, int row, int col)
{
    int i, j;
    for(i=0;i<row;i++)
    {
	for(j=0;j<col;j++)
	{
	    des[i][j]=src[i][j];    
	}
    }
    return 0;
}
// copy row x col content from a matrix (or part of a matrix, which can be larger than row x col)
int msacpy_float(float** des, float** src, int row, int col)
{
    int i, j;
    for(i=0;i<row;i++)
    {
	for(j=0;j<col;j++)
	{
	    des[i][j]=src[i][j];    
	}
    }
    return 0;
}

// Eliminate the equalities in the linear programming program
int elsomerows(double**& a, double**& b, int lfcol, int rtcol, int* mf, int &m, int* nf, int& n)
{
    int i, j, mind, tmp, cc, h, k;
    float ra, minra;
    int* mmf;
    mmf=new int[m];
    for(j=lfcol;j<rtcol;j++)    	 
    {
	mind=-1;
	minra=-1;
	for(i=0;i<m-1;i++)
	{
	    if (a[i][j]>0 && mf[i]!=-2)
	    {
		ra=fabs(a[m-1][j]/a[i][j]);       
		if (minra<0 || ra<minra)
		{
		    minra=ra;
		    mind=i;
		}
	    }
	}
	if (mind!=-1)
	{
	    //   cout<<"j="<<j<<" lf="<<lfcol<<" rt="<<rtcol<<endl;
	    //    cout<<"("<<mind<<", "<<j<<") is pivot"<<endl;
	    tmp=mf[mind];
	    mf[mind]=nf[j];
	    nf[j]=tmp;
	    pivot(a, b, mind, j, m, n);
	}
	else
	{
	    cout<<"Error in elsomerows"<<endl;
	}

	//	dispvector_int(mf, m, 3);
    }
    /*
       cc=0;
       for(i=0;i<m;i++)
       {
       if (mf[i]!=-2)
       {
       for(j=0;j<n;j++)
       {
       b[cc][j]=a[i][j];
       mmf[cc]=mf[i];
       }
       cc++;
       }
       }
       for(i=0;i<cc;i++)
       {
       mf[i]=mmf[i];
       for(j=0;j<n;j++)
       {
       a[i][j]=b[i][j];
       }
       }
       cout<<"cc="<<cc<<endl;
       m=cc;
       */



    delete [] mmf;
    return 0;
}

// Solve the linear programming problem and store the results in array est
int solvelpmin(double** a, double** b, int* mf, int m, int* nf, int n)
{
    int i, j, rs;
    rs=standardlpmin(a, b, mf, m, nf, n);
    return rs;
}


// Solve the linear programming problem and store the results in array est
int solvelpmin(double** a, double** b, int* mf, int m, int* nf, int n, double* est)
{
    int i, j, rs;
    rs=standardlpmin(a, b, mf, m, nf, n);

    //    if (rs>0)
    //    {
    /*
       for(i=0;i<m-1;i++)
       {
       if (mf[i]>=0)
       {
       est[mf[i]]=0;
       }
       }
       */
    //	for(j=0;j<n-1;j++)
    //	{
    //	    if (nf[j]>=0)
    //	    {
    //		est[nf[j]]=a[m-1][j];
    //	    }
    //	}
    //	cout<<"We found an optimal solution, which is given by"<<endl;
    //    }
    /*
       else if (rs=-9999)
       {
       cout<<"There are unbounded feasible solutions, the maximum of them is given by, "<<endl;
       }
       else 
       {
       cout<<"There is no feasible solution"<<endl;
       }
       */
    return rs;
}

int dispvector_int(int* a, int len, int w)
{
    int i;
    cout<<setiosflags(ios::right);
    for(i=0;i<len;i++)
    {
	cout<<setw(w)<<a[i]<<" ";
    }
    cout<<endl;
}

int dispvector(double* a, int len, int w)
{
    int i;
    cout<<setiosflags(ios::right);
    for(i=0;i<len;i++)
    {
	cout<<setw(w)<<a[i]<<" ";
    }
    cout<<endl;
}

int dispvector_float(float* a, int len, int w)
{
    int i;
    cout<<setiosflags(ios::right);
    for(i=0;i<len;i++)
    {
	cout<<setw(w)<<a[i]<<" ";
    }
    cout<<endl;
}

int dispmatrix_float(float** a, int row, int col, int w)
{
    int i;
    for(i=0;i<row;i++)
    {
	dispvector_float(a[i], col, w);
    }
}

int dispmatrix(double** a, int row, int col, int w)
{
    int i;
    for(i=0;i<row;i++)
    {
	dispvector(a[i], col, w);
    }
}

//Randomly select a set of vectors as EM set
int initemsv2(float** data, int band, int* ida, int seeds, double** msa, int& m, int& n, 
	double lob, double upb, int* eminds, int*bdays,  int& pems, int* mmf)
{

    int i, ind, j, cc;


    cc=0;
    i=0;
    do
    {
	ind=ida[i];
	if (checkems(data, band, ind)>=0)
	{
	    msa[cc][0]=-1;
	    msa[cc][1]=1;
	    msa[cc][band+2]=1;
	    eminds[cc]=ind;
	    bdays[cc]=seeds;
	    mmf[cc]=cc;
	    for(j=0;j<band;j++)
	    {
		msa[cc][j+2]=(double) data[j][ind];
	    }
	    cc++;
	}
	i++;
    }while (cc<seeds);

    msa[seeds][0]=upb;
    msa[seeds][1]=-lob;
    msa[seeds][band+2]=0;

    m=seeds+1;
    n=band+3;
    pems=seeds;

    cout<<"In initems"<<endl;
    dispmatrix(msa, m, n, 8);

    return 0;
}




//Randomly select a set of vectors as EM set
int initemsv1(float** data, int chs, int band, gsl_rng* rng, int seeds, double** msa, int& m, int& n, 
	double lob, double upb, int* eminds, int& pems, int* mmf)
{

    int i, ind, j, cc;
    size_t* sts;
    double* u;

    u=new double[chs];
    sts=new size_t[chs];

    for(i=0;i<chs;i++)
    {
	u[i]=gsl_rng_uniform(rng);
    }
    gsl_sort_index(sts,u,1,chs);
    cc=0;
    for(i=0;i<chs;i++)
    {
	ind=sts[i];
	if (ind>5000 ||checkems(data, band, ind)<0)
	{
	    continue;
	}
	msa[cc][0]=-1;
	msa[cc][1]=1;
	msa[cc][band+2]=1;
	eminds[cc]=ind;
	mmf[cc]=cc;
	for(j=0;j<band;j++)
	{
	    msa[cc][j+2]=(double) data[j][ind];
	}
	cc++;
	if (cc>=seeds)
	{
	    break;
	}
    }


    msa[seeds][0]=upb;
    msa[seeds][1]=-lob;
    msa[seeds][band+2]=0;

    m=seeds+1;
    n=band+3;
    pems=seeds;

    cout<<"In initems"<<endl;
    dispmatrix(msa, m, n, 8);
    delete [] u;
    delete [] sts;

    return 0;
}


//Randomly select a set of vectors as EM set
int initems(float** data, int chs, int band, gsl_rng* rng, int seeds, double** msa, int& m, int& n, 
	double lob, double upb, int* pcls, int* eminds, int& pems, int* mmf)
{

    int i, ind, j, cc;
    size_t* sts;
    double* u;

    u=new double[chs];
    sts=new size_t[chs];

    for(i=0;i<chs;i++)
    {
	u[i]=gsl_rng_uniform(rng);
    }
    gsl_sort_index(sts,u,1,chs);
    cc=0;
    for(i=0;i<chs;i++)
    {
	ind=sts[i];
	if (pcls[ind]!=0 || ind>5000 ||checkems(data, band, ind)<0)
	{
	    continue;
	}
	msa[cc][0]=-1;
	msa[cc][1]=1;
	msa[cc][band+2]=1;
	eminds[cc]=ind;
	mmf[cc]=cc;
	pcls[ind]=1;
	for(j=0;j<band;j++)
	{
	    msa[cc][j+2]=(double) data[j][ind];
	}
	cc++;
	if (cc>=seeds)
	{
	    break;
	}
    }


    msa[seeds][0]=upb;
    msa[seeds][1]=-lob;
    msa[seeds][band+2]=0;

    m=seeds+1;
    n=band+3;
    pems=seeds;

    cout<<"In initems"<<endl;
    dispmatrix(msa, m, n, 8);
    delete [] u;
    delete [] sts;

    return 0;
}

// Write 6 index of EMs and corresponding abundance estimation of a pixel to the output file
int outputest(ofstream& fout, int* eminds, double* est, int m, int band, float* cot, 
	int* hits, double hitsth, int* mmf, int pems )
{
    int i, ind;
    size_t *sts;

    double sum=0;
    int cc=0;

    sts=new size_t[pems];
    gsl_sort_index(sts, est, 1, pems);
    for(i=0;i<band+1;i++)
    {
	ind=sts[pems-i-1];
	if (est[ind]>0)
	{
	    cot[i]=(float)eminds[ind];
	    cot[i+band+1]=(float)est[ind];
	    sum+=est[ind];
	    cc++;
	}
	else
	{
	    cot[i]=-1.0;
	    cot[i+band+1]=-1.0;
	}
    }

    //     cout<<"cc="<<cc<<" sum="<<sum;
    if (sum>1.01 || sum<0.99)
    {
	cout<<" abNormal"<<" sum="<<sum<<endl;
    }
    //    else
    //    {
    //    cout<<"Nomarl"<<endl;
    //    }

    //   cc=0;
    //   sum=0;
    for(i=pems-1;i>=0;i--)
    {
	ind=sts[i];
	if (est[ind]==0)
	{
	    break;
	}
	/*
	   if (est[ind]>0)
	   {
	   cc++;
	   sum+=est[ind];
	   }
	   */
	if (est[ind]>=hitsth)
	{
	    hits[ind]++;	
	}
    }
    /*
       cout<<"cc="<<cc<<" sum="<<sum;
       if (sum>=0.95)
       {
       cout<<" Normal"<<endl;
       }
       else
       {
       cout<<"Less"<<endl;
       }
       */
    fout.write((char*)cot, 2*(band+1)*sizeof(float));
    delete [] sts;
    return 0;
}

// Add new endmember, updata LP matrix and EM sets
int updateems(double** mmsa, double** msa, int* eminds, int& m, int& n, int& pems,
	int pindex, float** data, int band, int* mmf, int cc)
{
    int j;

    eminds[pems]=pindex+cc;
    for(j=2;j<band+2;j++)
    {
	mmsa[pems][j]=(double) data[j-2][pindex];
    }	
    pems++;

    if (checkems(data, band, pindex)>=0)
    {
	for(j=0;j<n;j++)
	{
	    msa[m][j]=msa[m-1][j];
	}
	for(j=2;j<band+2;j++)
	{
	    msa[m-1][j]=(double) data[j-2][pindex];
	}
	msa[m-1][0]=-1.0;
	msa[m-1][1]=1.0;
	msa[m-1][band+2]=1.0;
	mmf[m-1]=pems-1;
	m++;
    }
    return 0;
}




int resetlpmatrix(int cc, double** mmsa, double** mma, int &m, int &n, int* hits, int* mmf, int* eminds, int upm, int* bdays)
{
    int i, j, ind, idx, ts;	
    int lom;
    int*mmsf;
    size_t* sts;
    double* u;


    if (m<upm+10)
    {
	return 1;
    }

    ts=upm;


    mmsf = new int[m];
    sts = new size_t[m];
    u = new double[m];

    msacpy(mmsa, mma, m, n);

    for(i=0;i<m-1;i++)
    {
	ind=mmf[i];
	mmsf[i]=ind;
	idx=eminds[ind];
	u[i]=((double)hits[ind])/(cc-bdays[ind]);
    }

    gsl_sort_index(sts, u, 1, m-1);

    for(i=0;i<ts;i++)
    {
	ind=sts[m-2-i];
	for(j=0;j<n;j++)
	{
	    mma[i][j]=mmsa[ind][j];
	}
	mmf[i]=mmsf[ind];
    }

    m=ts+1;

    delete [] mmsf;
    delete [] sts;
    delete [] u;

}

int resetlpmatrix(int cc, double** mmsa, double** mma, int &m, int &n, int* hits, int* mmf, int* eminds, int upm)
{
    int i, j, ind, idx, ts;	
    int lom;
    int*mmsf;
    size_t* sts;
    double* u;

    //upm=300;
    //upm=400;

    if (m<upm+10)
    {
	return 1;
    }

    ts=upm;


    mmsf = new int[m];
    sts = new size_t[m];
    u = new double[m];

    msacpy(mmsa, mma, m, n);

    for(i=0;i<m-1;i++)
    {
	ind=mmf[i];
	mmsf[i]=ind;
	idx=eminds[ind];
	u[i]=((double)hits[ind])/(cc-idx);
    }

    gsl_sort_index(sts, u, 1, m-1);

    for(i=0;i<ts;i++)
    {
	ind=sts[m-2-i];
	for(j=0;j<n;j++)
	{
	    mma[i][j]=mmsa[ind][j];
	}
	mmf[i]=mmsf[ind];
    }

    m=ts+1;

    delete [] mmsf;
    delete [] sts;
    delete [] u;

}


// Remove the Em with lower hits from the LP matrix 
int shrinkems(int cc, double** mmsa,  double** msa, int& m, int& n, int* mmf, int* eminds, int* hits, 
	int band, int pems, double lob, double upb)
{
    int i, j, ts, ind, pindex; 
    double* u;
    size_t* sts;
    int lom, upm;

    lom=100;
    upm=300;
    //upm=150;

    if (pems<lom)
    {
	return 1;
    }
    sts =new size_t[pems];
    u =new double[pems];

    for(i=0;i<pems;i++)
    {
	u[i]=((double)hits[i])/(cc-eminds[i]);
    }
    gsl_sort_index(sts, u, 1, pems);
    ts=pems/2;
    if (ts<lom)
    {
	ts=lom;
    }
    if (ts>upm)
    {
	ts=upm;
    }

    cout<<"ts="<<ts<<endl;
    for(i=0;i<ts;i++)
    {
	ind=sts[pems-1-i];
	mmf[i]=ind;
	msa[i][0]=-1;	    
	msa[i][1]=1;	    
	msa[i][n-1]=1;	    
	//	if (i<100)
	//	{
	cout<<"i="<<i<<" ind="<<ind<<" u="<<u[ind]<<"  hits="<<hits[ind]<<" pindex="<<eminds[ind]<<" cc-eminds="<<cc-eminds[ind];
	cout<<" b5="<<mmsa[ind][4+2]<<" b4/b3="<<mmsa[ind][3+2]/mmsa[ind][2+2]<<endl;
	//	}
	for(j=0;j<band;j++)
	{
	    msa[i][j+2]=mmsa[ind][j+2];
	}
    } 
    msa[ts][0]=upb;
    msa[ts][1]=-lob;
    msa[ts][band+2]=0;
    m=ts+1;

    delete [] u;
    delete [] sts;
    return 0;
}

int transtime( int t, int &dd, int&hh, int& mm, int& secs)
{

    dd=(int)floor(t/(24*60*60));
    t-=dd*24*60*60;
    hh=(int)floor(t/(60*60));
    t-=hh*60*60;
    mm=(int)floor(t/60);
    t-=mm*60;
    secs=t;
}


int delimitedtxt(string ifname, char* indet, int len, char outdet, string ofname)
{
    int i, j,  ss, lastpos;
    bool flag, first;
    ifstream fin;
    ofstream fout;
    int bs=1024*1024;
    char*  buf;
    string st, atom, outst;

    fin.open(ifname.c_str(), ios::in);
    if (fin.good())
    {
	cout<<"Successfully open input file "<<ifname<<endl;
    }
    else
    {
	cout<<"Fail to open input file "<<ifname<<endl;
	return -1;
    }
    fout.open(ofname.c_str(), ios::out);
    if (fout.good())
    {
	cout<<"Successfully open output file "<<ofname<<endl;
    }
    else
    {
	cout<<"Fail to open output file "<<ofname<<endl;
	return -3;
    }

    buf=new char[bs];
    while(!fin.eof())
    {
	fin.getline(buf, bs, '\n');
	st=buf;
	ss=st.length();
	outst="";
	lastpos=0;
	flag=true;
	first=true;
	for(i=0;i<ss;i++)
	{
	    for(j=0;j<len;j++)
	    {
		if (st[i]==indet[j] )
		{
		    if (flag)
		    {
			flag=false;
			if (!first)
			{
			    fout<<outdet;
			}
			else
			{
			    first=false;
			}
			atom=st.substr(lastpos, i-lastpos);
			fout<<atom;
			lastpos=i+1;
			break;
		    }
		    else
		    {
			lastpos++;
			break;
		    }
		}
		else
		{
		    if (j==len-1)
		    {
			flag=true;
		    }
		}
	    }
	}
	if (ss-lastpos>=1)
	{
	    atom=st.substr(lastpos, ss-lastpos);
	    fout<<outdet<<atom;
	}
	fout<<endl;
    }

    delete [] buf;
}

int findtspara(float* data, float* mdata, int ts, int nms)
{
    int i, cc;
    float sum;
    for(i=0;i<nms;i++)
    {
	mdata[i]=-1;
    }
    cc=0;
    sum=0;
    for(i=0;i<ts;i++)
    {
	if (data[i]>0 && !isnan(data[i]) )
	{
	    cc++;
	    sum+=data[i];
	    if (data[i]>mdata[0])
	    {
		mdata[0]=data[i];
		mdata[nms-1]=i;
	    }
	    if (data[i]<mdata[1] || mdata[1]==-1)
	    {
		mdata[1]=data[i];
	    }
	}
    }
    if (cc!=0)
    {
	mdata[2]=sum/cc;
    }
    else
    {
	mdata[2]=-1;
    }
    if (mdata[1]!=-1)
    {
	mdata[3]=mdata[0]/mdata[1];
    }
    else
    {
	mdata[1]=-1;
    }


}

// calculate the distance matrix for a set of pixels, the distance is defined as projective angle between two vectors
int   calnnmat(double** nnmat, int trs, int* nninds, int band, float** a)
{
    int i, j, k, m, n;
    float *norm;
    float sum;	

    norm=new float[trs];
    for(i=0;i<trs;i++)
    {
	norm[i]=0;
	m=nninds[i];
	//cout<<"i="<<i<<" m="<<m<<endl;
	for(k=0;k<band;k++)
	{
	    norm[i]+=a[m][k]*a[m][k];
	}
	norm[i]=sqrt(norm[i]);
	nnmat[i][i]=0;
    }
    for(i=0;i<trs-1;i++)
    {
	m=nninds[i];
	for(j=i+1;j<trs;j++)
	{
	    n=nninds[j];
	    sum=0;
	    //cout<<"m="<<m<<" n="<<n<<endl;
	    for(k=0;k<band;k++)
	    {
		sum+=a[m][k]*a[n][k];
	    }
	    nnmat[i][j]=acos(sum/(norm[i]*norm[j]));
	    nnmat[j][i]=nnmat[i][j];
	}
    }

    delete [] norm;
}

int openintxtfile(string ifname, ifstream& fin)
{
    fin.open(ifname.c_str(), ios::in);
    if (!fin.good())
    {
	cout<<"Fail to open the input file "<<ifname<<"\n";
	return -2;
    }
    else
    {
//	cout<<"Open input file "<<ifname<<" successfully"<<endl;
    }
    return 0;

}

int openouttxtfile(string ofname, ofstream& fout)
{
    fout.open(ofname.c_str(), ios::out);
    if (!fout.good())
    {
	cout<<"Fail to open the output file "<<ofname<<"\n";
	return -2;
    }
    else
    {
	cout<<"Open output file "<<ofname<<" in text mode successfully"<<endl;
    }
    return 0;

}

int readdatafile(string ifname, float**& data, int& irow, int& icol)
{
    ifstream fin;
    char c;
    char buf[1024*256];
    bool flag;
    string st, sst;
    int i, j, dcc, ss, be, len; 
    vector<int> items;

    if (openintxtfile(ifname, fin)<0)
    {
	return -1;
    }
    irow=countlines(fin, items);
    icol=items[0];
    fin.close();
    openintxtfile(ifname, fin);
    data = new float*[irow];
    for(i=0;i<irow;i++)
    {
	data[i]=new float[icol];
    }
    fin.seekg(ios::beg);
    for (i=0;i<irow;i++)
    {
	fin.getline(buf, 1024*256, '\n');
	st=buf;
	ss=st.size();
	dcc=0;
	flag=false;
	for(j=0;j<ss;j++)
	{
	    c=st[j];
	    if (((c>='0' && c<='9') || (c>='a' && c<='z') || (c>='A' && c<='Z') || c=='.') && !flag)
	    {
		flag=true;
		be=j;
	    }
	    else if (flag &&(c==' ' || c==',' || c=='\t' || j==ss-1))
	    {
		flag=false;
		len=j-be;
		sst=st.substr(be, len);
		data[i][dcc]=atof(sst.c_str());
		dcc++;
	    }
	}
	if (flag)
	{
	    len=j-be;
	    sst=st.substr(be, len);
	    data[i][dcc]=atof(sst.c_str());
	    dcc++;
	}
    }
    fin.close();
    return 0;
}

int readdatafile(string ifname, double**& data, int& irow, int& icol)
{
    ifstream fin;
    char c;
    char buf[1024*256];
    bool flag;
    string st, sst;
    int i, j, dcc, ss, be, len; 
    vector<int> items;

    if (openintxtfile(ifname, fin)<0)
    {
	return -1;
    }
    irow=countlines(fin, items);
    icol=items[0];
    fin.close();
    openintxtfile(ifname, fin);
    data = new double*[irow];
    for(i=0;i<irow;i++)
    {
	data[i]=new double[icol];
    }
    fin.seekg(ios::beg);
    for (i=0;i<irow;i++)
    {
	fin.getline(buf, 1024*256, '\n');
	st=buf;
	ss=st.size();
	dcc=0;
	flag=false;
	for(j=0;j<ss;j++)
	{
	    c=st[j];
	    if (((c>='0' && c<='9') || (c>='a' && c<='z') || (c>='A' && c<='Z') || c=='.' || c=='+' || c=='-') && !flag)
	    {
		flag=true;
		be=j;
	    }
	    else if (flag &&(c==' ' || c==',' || c=='\t' || j==ss-1))
	    {
		flag=false;
		len=j-be;
		sst=st.substr(be, len);
		data[i][dcc]=atof(sst.c_str());
		dcc++;
	    }
	}
	if (flag)
	{
	    len=j-be;
	    sst=st.substr(be, len);
	    data[i][dcc]=atof(sst.c_str());
	    dcc++;
	}
    }
    fin.close();
    return 0;
}

int writedatafile(string ofname, float** data, int irow, int icol, char det)
{
    int i, j, rfss;
    ofstream fout;
    if (irow<=0 || icol<=0)
    {
	return -1;
    }
    rfss=openouttxtfile(ofname, fout);
    if (rfss<0)
    {
	return rfss;
    }
    for(i=0;i<irow;i++)
    {
	for(j=0;j<icol;j++)
	{
	    fout<<data[i][j];
	    if (j!=icol-1)
	    {
		fout<<det;
	    }
	    else
	    {
		fout<<'\n';
	    }
	}
    }
    fout.close();
    return 0;
}

string ftostr( float value )
{
    ostringstream oss;
    oss << value;
    return oss.str();
}

string itostr( int value )
{
    ostringstream oss;
    oss << value;
    return oss.str();
}

string longtostr( long value )
{
    ostringstream oss;
    oss << value;
    return oss.str();
}

int zotransform(float** data, int irow, int icol, float* scf)
{
    int i, j;
    float maxcol, mincol, mag;
    for(j=0;j<icol;j++)
    {
	maxcol=data[0][j];
	mincol=data[0][j];
	for(i=1;i<irow;i++)
	{
	    if (data[i][j]>maxcol)
	    {
		maxcol=data[i][j];
	    }
	    if (data[i][j]<mincol)
	    {
		mincol=data[i][j];
	    }
	}
	if (maxcol==mincol)
	{
	    for(i=0;i<irow;i++)
	    {
		data[i][j]=1.0;
	    }
	    scf[j*2]=0;
	    scf[j*2+1]=maxcol;

	}
	else
	{
	    mag=maxcol-mincol;
	    for(i=0;i<irow;i++)
	    {
		data[i][j]=(data[i][j]-mincol)/mag;
	    }
	    scf[j*2]=mincol;
	    scf[j*2+1]=mag;
	}

    }
}

int deletematrix(int**& data, int irow)
{

    int i;
    if (irow<=0)
    {
	return -1;
    }
    for(i=0;i<irow;i++)
    {	
	delete [] data[i];
    }
    delete [] data;
    return 0;
}

int deletematrix(bool**& data, int irow)
{

    int i;
    if (irow<=0)
    {
	return -1;
    }
    for(i=0;i<irow;i++)
    {	
	delete [] data[i];
    }
    delete [] data;
    return 0;
}

int creatematrix(bool**& data, int irow, int icol)
{
    int i;
    if (irow<=0 || icol<=0)
    {
	return -1;
    }
    data=new bool*[irow];
    for(i=0;i<irow;i++)
    {	
	data[i]=new bool[icol];
    }
    return 0;
}


int creatematrix(int**& data, int irow, int icol)
{
    int i;
    if (irow<=0 || icol<=0)
    {
	return -1;
    }
    data=new int*[irow];
    for(i=0;i<irow;i++)
    {	
	data[i]=new int[icol];
    }
    return 0;
}


int creatematrix(float**& data, int irow, int icol)
{
    int i;
    if (irow<=0 || icol<=0)
    {
	return -1;
    }
    data=new float*[irow];
    for(i=0;i<irow;i++)
    {	
	data[i]=new float[icol];
    }
    return 0;
}

int deletematrix(float**& data, int irow)
{

    int i;
    if (irow<=0)
    {
	return -1;
    }
    for(i=0;i<irow;i++)
    {	
	delete [] data[i];
    }
    delete [] data;
    return 0;
}

int addfeatures(float** msa, float** & data, int irow, int band)
{
    int i, j;
    float ssum, asum;
    data=new float*[irow];
    for(i=0;i<irow;i++)
    {
	data[i]=new float[band+5];
	ssum=0;
	asum=0;

	for(j=0;j<band;j++)
	{
	    data[i][j]=msa[i][j];
	    ssum+=data[i][j]*data[i][j];
	    asum+=data[i][j];
	}

	data[i][band]=data[i][5]/data[i][4];
	data[i][band+1]=data[i][3]/data[i][2];
	data[i][band+2]=data[i][4]/data[i][1];
	data[i][band+3]=sqrt(ssum);
	data[i][band+4]=acos(asum/(sqrt(ssum)*sqrt(band)));

    }
    return 0;
}

int addfeatures(float** msa, float** & data, int irow, int band, int* pcls)
{
    int i, j;
    float ssum, asum;
    creatematrix(data, irow, band+5);
    for(i=0;i<irow;i++)
    {
	if (pcls[i]==1 || pcls[i]==3)
	{
	    ssum=0;
	    asum=0;

	    for(j=0;j<band;j++)
	    {
		data[i][j]=msa[j][i];
		ssum+=data[i][j]*data[i][j];
		asum+=data[i][j];
	    }

	    data[i][band]=data[i][5]/data[i][4];
	    data[i][band+1]=data[i][3]/data[i][2];
	    data[i][band+2]=data[i][4]/data[i][1];
	    data[i][band+3]=sqrt(ssum);
	    data[i][band+4]=acos(asum/(sqrt(ssum)*sqrt(band)));
	}

    }
    return 0;
}

string trim(const string& st)
{

    int pos, size, le, ri;
    string trim_st=st;

    size=st.length();
    if (size<=1)
	return trim_st;

    pos=0;
    while(st[pos]<33 || st[pos]>126)
    {
	pos++;	
	if (pos>=st.length())
	    break;
    }
    le=pos;

    pos=size-1;
    while(st[pos]<33 || st[pos]>126)
    {
	pos--;
	if (pos<=0)
	    break;

    }	
    ri=pos;
    trim_st=st.substr(le, ri-le+1);

    return trim_st;
}
// copy row x col content from a matrix (or part of a matrix, which can be larger than row x col), and create the destine matrix
int msbcpy(double**& des, double** src, int row, int col)
{
    int i, j;

    des=new double*[row];
    for(i=0;i<row;i++)
    {
	des[i]=new double[col];
	for(j=0;j<col;j++)
	{
	    des[i][j]=src[i][j];    
	}
    }
    return 0;
}
// copy row x col content from a matrix (or part of a matrix, which can be larger than row x col), and create the destine matrix
int msbcpy_float(float**& des, float** src, int row, int col)
{
    int i, j;

    des=new float*[row];
    for(i=0;i<row;i++)
    {
	des[i]=new float[col];
	for(j=0;j<col;j++)
	{
	    des[i][j]=src[i][j];    
	}
    }
    return 0;
}

// Check a pixel to see if it can be placed into LP matrix
int checkems(float** data, int band, int ind)
{
    int i;
    float thod;

    thod=0.001;
    for(i=0;i<band;i++)
    {	    
	if (data[i][ind]<thod || data[i][ind]>0.75)
	{
	    return -1;
	}
    }
    return 0;
}

int unmixems(double** ma, int dm, bool*  tyma)
{
    int i, j, k;
    double inv;


    for(i=0;i<dm-1;i++)
    {
	if (tyma[i])	
	{
	    for(j=i+1;j<dm;j++)
	    {
		if (tyma[j])
		{
		    inv=ma[j][i]/ma[i][i];
		    for(k=0;k<dm;k++)
		    {
			ma[j][k]-=inv*ma[i][k];
		    }
		}
	    }
	}
    }

    for(i=dm-1;i>0;i--)
    {
	if (tyma[i])
	{
	    inv=-ma[i][i];
	    for(k=0;k<dm;k++)
	    {
		ma[i][k]/=inv;
	    }
	    for(j=i-1;j>=0;j--)
	    {
		inv=ma[j][i];
		for(k=0;k<dm;k++)
		{
		    ma[j][k]+=inv*ma[i][k];
		}
	    }
	}
    }
    //	    dispmatrix(ma, dm, dm, 8);
    //	    cout<<endl;

}


int deletematrix(double**& data, int irow)
{

    int i;
    if (irow<=0)
    {
	return -1;
    }
    for(i=0;i<irow;i++)
    {	
	delete [] data[i];
    }
    delete [] data;
    return 0;
}

int creatematrix(double**& data, int irow, int icol)
{
    int i;
    if (irow<=0 || icol<=0)
    {
	return -1;
    }
    data=new double*[irow];
    for(i=0;i<irow;i++)
    {	
	data[i]=new double[icol];
    }
    return 0;
}

int creatematrix(double**& data, int irow, int icol, double t)
{
    int i;
    if (irow<=0 || icol<=0)
    {
	return -1;
    }
    data=new double*[irow];
    for(i=0;i<irow;i++)
    {	
	data[i]=new double[icol];
    }
    setmatrix(data, irow, icol, t);
    return 0;
}

int setmatrix(double**& data, int irow, int icol, double t)
{
    int i, j;
    if (irow<=0 || icol<=0)
    {
	return -1;
    }
    for(i=0;i<irow;i++)
    {
	for(j=0;j<icol;j++)
	{
	    data[i][j]=t;
	}
    }
    return 0;
}

// unmix a set of pixels
int unmixasubset(double** mma, int m, int n, int* mmf, int band, double upb, double lob, float** data, int* pcls, int bidx, 
	int eidx, float* cot, size_t* sts)
{
    int i, j;
#pragma omp parallel private(i, j) firstprivate(band, m, n, upb, lob)
#pragma omp for schedule(dynamic,50) nowait

    for(j=bidx;j<eidx;j++)
    {
	i=sts[j];
	if (pcls[i]==0)
	{
	    unmixonepixel(mma, m, n, mmf, band, upb, lob, i, data, &cot[i*(band+2)*2]);
	}
    }
    return 0;
}    

// unmix a set of pixels
int unmixasubset(double** mma, int m, int n, int* mmf, int band, double upb, double lob, float** data, int* pcls, int bidx, int eidx, float* cot)
{
    int i, rs, ind;

    cout<<"m="<<m<<endl;

    for(i=0;i<m-1;i++)
    {
	ind=mmf[i];
	mmf[i]=-2;
	rs=unmixonepixel(mma, m, n, mmf, band, upb, lob, ind, data, &cot[ind*(band+2)*2]);
	mmf[i]=ind;
	if (rs>0)  // 
	{
	    pcls[ind]=2;
	}
	else
	{
	    pcls[ind]=1;
	}
    }


#pragma omp parallel private(i, rs) firstprivate(band, m, n, upb, lob)
#pragma omp for schedule(dynamic,50) nowait

    for(i=bidx;i<eidx;i++)
    {
	if (pcls[i]==0)
	{
	    rs=unmixonepixel(mma, m, n, mmf, band, upb, lob, i, data, &cot[i*(band+2)*2]);
	    if (rs>0)
	    {
		pcls[i]=2;
	    }
	    else
	    {
		pcls[i]=3;
	    }
	}
    }
    return 0;
}
// unmix a set of pixels
int unmixasubsetv1(double** mma, int m, int n, int* mmf, int band, double upb, double lob, float** data, int bidx, 
	int eidx, float* cot)
{
    int i;

    cout<<"m="<<m<<endl;
#pragma omp parallel private(i) firstprivate(band, m, n, upb, lob, bidx, eidx)
#pragma omp for schedule(dynamic,50) nowait

    for(i=bidx;i<eidx;i++)
    {
	unmixonepixel(mma, m, n, mmf, band, upb, lob, i, data, &cot[(i-bidx)*(band+2)*2]);
    }
    return 0;
}

// unmix a set of pixels
int unmixasubset(double** mma, int m, int n, int* mmf, int band, double upb, double lob, float** data, int bidx, 
	int eidx, float* cot)
{
    int i;

    cout<<"m="<<m<<endl;
#pragma omp parallel private(i) firstprivate(band, m, n, upb, lob)
#pragma omp for schedule(dynamic,50) nowait

    for(i=bidx;i<eidx;i++)
    {
	unmixonepixel(mma, m, n, mmf, band, upb, lob, i, data, &cot[i*(band+2)*2]);
    }
    return 0;
}

// unmix a set of pixels
int unmixasubset(double** mma, int m, int n, int* mmf, int band, double upb, double lob, float** data, int bidx, 
	int eidx, float* cot, int* ida)
{
    int i, ind;

    cout<<"m="<<m<<endl;
#pragma omp parallel private(i, ind) firstprivate(band, m, n, upb, lob, bidx, eidx)
#pragma omp for schedule(dynamic,50) nowait

    for(i=bidx;i<eidx;i++)
    {
	ind=ida[i];
	unmixonepixel(mma, m, n, mmf, band, upb, lob, ind, data, &cot[(i-bidx)*(band+2)*2]);
    }
    return 0;
}

// Unmix one pixel using the LP algorithm, mma stores the LP matrix while mmf stores the corresponding index of vector
int unmixonepixel(double** mma, int m, int n, int* mmf, int band, double upb, double lob, int idx, float** data, float* cot)
{
    int rs;
    int i, j, ind, pp;
    int *nf, *mf;
    double **b, **a;
    double sum, frac;

    /*
       cout<<"idx="<<idx<<" ";
       cout<<data[0][idx]<<" ";
       cout<<data[1][idx]<<" ";
       cout<<data[2][idx]<<" ";
       cout<<data[3][idx]<<" ";
       cout<<data[4][idx]<<" ";
       cout<<data[5][idx]<<" "<<endl;
       */

    if (data[1][idx]<=0 || data[2][idx]<=0 || data[3][idx]<=0 || data[0][idx]<0 ||data[4][idx]<0.05 || data[5][idx]<0)
    {
	cot[0]=-2;
	cot[1]=-2;
	return -2;
    }

    nf=new int[n];
    mf=new int[m];


    creatematrix(a, m, n);
    creatematrix(b, m, n);
    msacpy(a, mma, m, n);
    for(j=0;j<band;j++)
    {
	a[m-1][j+2]=(double) -data[j][idx];
    }
    a[m-1][0]=upb;
    a[m-1][1]=-lob;
    a[m-1][n-1]=0;

    for(j=0;j<m-1;j++)
    {
	mf[j]=mmf[j];
    }
    mf[m-1]=-1;

    nf[0]=-1;
    nf[1]=-1;
    nf[n-1]=-1;
    nf[n-1]=-1;
    for(j=2;j<n-1;j++)
    {
	nf[j]=-2;
    }


    elsomerows(a, b, 2, n-1, mf, m, nf, n);
    rs=solvelpmin( a, b, mf,  m, nf, n);


    if (rs>0)
    {
	sum=0;
	for(j=0;j<n-1;j++)
	{
	    if (nf[j]>=0)
	    {
		sum+=a[m-1][j];
	    }
	}
    }

    if (rs>0 && sum<1.01 && sum>0.99)
    {
	pp=0;    
	for(j=0;j<n-1;j++)
	{
	    ind=nf[j];
	    if (ind>=0)
	    {
		frac=a[m-1][j]/sum;
		cot[pp]=(float)ind;
		pp++;
		cot[pp]=frac;
		pp++;
	    }
	}   
    }
    else
    {
	rs=-1;
    }

    deletematrix(a, m);
    deletematrix(b, m);
    delete [] nf;
    delete [] mf;

    //cout<<"rs="<<rs<<endl;
    return rs;

}

int filterdata(float**& data, int& irow, int icol, float thod)
{
    float** mdata;
    bool* pcls;
    int i, j, pp, cc;

    pcls=new bool[irow];
    pp=irow;
    for(i=0;i<irow;i++)
    {
	pcls[i]=false;
	for(j=0;j<icol-1;j++)
	{
	    if (data[i][j]<thod)
	    {
		pcls[i]=true;
		pp--;
		break;
	    }
	}
    }
    creatematrix(mdata, pp, icol);
    cc=0;
    for(i=0;i<irow;i++)
    {
	if (!pcls[i])
	{
	    for(j=0;j<icol;j++)
	    {
		mdata[cc][j]=data[i][j];
	    }
	    cc++;
	}

    }
    deletematrix(data, irow);
    data=mdata;
    irow=pp;
    delete [] pcls;
    return irow;
}

int filterdata(double**& data, int& irow, int icol, float thod)
{
    double** mdata;
    bool* pcls;
    int i, j, pp, cc;

    pcls=new bool[irow];
    pp=irow;
    for(i=0;i<irow;i++)
    {
	pcls[i]=false;
	for(j=0;j<icol-1;j++)
	{
	    if (data[i][j]<thod)
	    {
		pcls[i]=true;
		pp--;
		break;
	    }
	}
    }
    creatematrix(mdata, pp, icol);
    cc=0;
    for(i=0;i<irow;i++)
    {
	if (!pcls[i])
	{
	    for(j=0;j<icol;j++)
	    {
		mdata[cc][j]=data[i][j];
	    }
	    cc++;
	}

    }
    deletematrix(data, irow);
    data=mdata;
    irow=pp;
    delete [] pcls;
    return irow;
}


int readhdrfile(string ifname, envihdr& ehd)
{
    int i, rs, pos, ss, pos2;
    string st, notfound;
    char buf[12*1024];
    ifstream fin;
    string marks[18], atom[18];

    notfound="notfound";
    marks[0]= "description";
    marks[1]= "samples";
    marks[2]= "lines";
    marks[3]= "bands";
    marks[4]= "header offset";
    marks[5]= "file type";
    marks[6]= "data type";
    marks[7]= "interleave";
    marks[8]= "sensor type";
    marks[9]= "byte order";
    marks[10]= "x start";
    marks[11]= "y start";
    marks[12]= "map info";
    marks[13]= "wavelength units";
    marks[14]= "band names";
    marks[15]= "wavelength";
    marks[16]= "projection info";
    marks[17]= "coordinate system string";

    if (openintxtfile(ifname, fin)<0)
    {
	return -1;
    }

    for(i=0;i<18;i++)
    {
	fin.seekg(0, ios::beg);
	if (i==15)
	{
	    rs=findmarker(fin, marks[i], st, 2);
	}
	else
	{
	    rs=findmarker(fin, marks[i], st, 1);
	}
	fin.clear();
	if (rs<0)
	{
	    //cout<<"Fail to find "<<marks[i]<<" in the file."<<endl;
	    //atom[i]=notfound;
	}
	else
	{
	    //cout<<"Find "<<marks[i]<<" in the file."<<endl;
	    pos=st.find('=');
	    if (pos<0)
	    {
		cout<<"Invalid input in the hdr file for "<<marks[i]<<endl;
	    }
	    else
	    {
		ss=st.length();
		atom[i]=st.substr(pos+1, ss-pos-1);
		if (i==0 || i==12 || i==14 ||i==15)
		{
		    pos=st.find('{');	
		    if (pos<0)
		    {
			while(true)
			{
			    if (fin.eof())
			    {
				break;
			    }
			    fin.getline(buf, 1024*12, '\n');
			    st=buf;
			    pos=st.find('{');
			    if (pos>=0)
			    {
				break;
			    }
			}
		    }
		    
		    if (pos>=0)
		    {
			pos2=st.find('}');	
			if (pos2>0)
			{
			    atom[i]=st.substr(pos+1, pos2-pos-1);
			}
			else
			{
			    atom[i]=st.substr(pos+1, ss-pos-1);
			    while(true)
			    {
				fin.getline(buf, 1024*12, '\n');
				st=buf;
				pos=st.find('}');	

				if (pos>=0)
				{
				    if (pos>0)
				    {
					atom[i]=atom[i]+' '+st.substr(0, pos);
				    }
				    break;
				}
				else
				{
				    atom[i]=atom[i]+' '+buf;
				}
			    }
			}
		    }
		}
	    }
	}
    }

    ehd.description=atom[0];
    if (atom[1].length()>0)
    {
	ehd.samples=atoi(atom[1].c_str());
    }
    else
    {
	ehd.samples=-9999;
    }


    if (atom[2].length()>0)
    {
	ehd.lines=atoi(atom[2].c_str());
    }
    else
    {
	ehd.lines=-9999;
    }
    if (atom[3].length()>0)
    {
	ehd.bands=atoi(atom[3].c_str());
    }
    else
    {
	ehd.bands=-9999;
    }
    if (atom[4].length()>0)
    {
	ehd.header_offset=atoi(atom[4].c_str());
    }
    else
    {
	ehd.header_offset=-9999;
    }
    ehd.file_type=atom[5];
    if (atom[6].length()>0)
    {
	ehd.data_type=atoi(atom[6].c_str());
    }
    else
    {
	ehd.data_type=-9999;
    }

    ehd.interleave=atom[7];
    ehd.sensor_type=atom[8];
    if (atom[9].length()>0)
    {
	ehd.byte_order=atoi(atom[9].c_str());
    }
    else
    {
	ehd.byte_order=-9999;
    }
    if (atom[10].length()>0)
    {
	ehd.xstart=atoi(atom[10].c_str());
    }
    else
    {
	ehd.xstart=-9999;
    }
    if (atom[11].length()>0)
    {
	ehd.ystart=atoi(atom[11].c_str());
    }
    else
    {
	ehd.ystart=-9999;
    }

    ehd.map_info=atom[12];
    ehd.wavelength_units=atom[13];
    ehd.band_names=atom[14];
    ehd.wavelength=atom[15];
    ehd.projection_info=atom[16];
    ehd.coordinate_system_string=atom[17];
    
    //cout<<"band names="<<atom[14]<<endl;
    fin.close();
    return 0;
}

int exthdrmapinfo(string mapinfo, double& lat, double& lon, double& lat_step, double& lon_step)
{
    string st;
    int i, ss, pos;

    for(i=0;i<3;i++)
    {
	ss=mapinfo.size();
	pos=mapinfo.find(',');
	if (pos<0)
	{
	    return -1;
	}
	mapinfo=mapinfo.substr(pos+1, ss-pos-1);
    }

    for(i=0;i<4;i++)
    {
	ss=mapinfo.size();
	pos=mapinfo.find(',');
	st=mapinfo.substr(0, pos);
	mapinfo=mapinfo.substr(pos+1, ss-pos-1);
	if (i==0)
	{
	    lon=atof(st.c_str());
	}
	else if (i==1)
	{
	    lat=atof(st.c_str());
	}
	else if (i==2)
	{
	    lon_step=atof(st.c_str());
	}
	else if (i==3)
	{
	    lat_step=atof(st.c_str());
	}
    }

    return 0;
}




// Unmix a rectangle block of Landsat image, the whole image is stored in img in row order, 
// the position of the top left corner is located at by rindex (row index), cidenx (column index)
// ncol -- the number of columns in the whole imagery
// irow -- the number of rows in the block
// icol -- the number of columns in the block
// flc -- fractional land cover estimations for each pixel in the block in row order
// ems -- spectral values (6 bands), label, x, y coordinates of the endmembers found in the block
// ne -- the number of endmembers found in the block
// mp -- projective matrix
// tpoints -- training samples in new feature space, each sample represented by a row in the matrix
// acls -- the labels of the training samples
// icvm -- the inverse of the covariance matrix, 

int unmixablock(float** img, int ncol, int rindex, int cindex, int irow, int icol, double**& flc, float**& ems, int& ne, 
	gsl_matrix* mp, gsl_matrix* tpoints, int* acls,  gsl_matrix* icvm)
{




}


svminfo* createsvminfo(int bs)
{
    svminfo* svf;
    svf = new svminfo;
    svf->a=new double[bs];
    svf->svind= new int[bs];
    svf->svcuts=new int[bs];
    
    return svf;
}

int deletesvminfo(svminfo* svf)
{   
    delete [] svf->a;
    delete [] svf->svind;
    delete [] svf->svcuts;
    delete svf;
    return 0;
}


// Find the index number of the element of arr  which has the closest value to val, the arr had been sorted in either ascending and descending order
size_t find_closest_value_index(double val, double* arr, size_t maxidx, int direction)
{
    
    size_t i, pos, lowb, highb;
    double cur, a1, a2;

    if (maxidx<1)
    {
	return maxidx;
    }


    lowb=0;
    highb=maxidx;
    if (direction==0) // The arr had been sorted in ascending order 
    {
	while (true)
	{
	    pos=(highb+lowb)/2;
	    if (highb==lowb)
	    {
		return highb;     	
	    }
	    else if (highb-lowb==1)
	    {
		a1=fabs(val-arr[lowb]);
		a2=fabs(val-arr[highb]);
		if (a1<a2)
		{
		    return lowb;
		}
		else
		{
		    return highb;
		}
	    }

	    cur=arr[pos];
	    if (cur==val)
	    {
		return pos;
	    }
	    else if (cur>val)
	    {
		highb=pos;
	    }
	    else
	    {
		lowb=pos;
	    }
	}
    }	
    else // The arr had been sorted in descending order
    {

    	while (true)
	{
	    pos=(highb+lowb)/2;
	    if (highb==lowb)
	    {
		return highb;     	
	    }
	    else if (highb-lowb==1)
	    {
		a1=fabs(val-arr[lowb]);
		a2=fabs(val-arr[highb]);
		if (a1<a2)
		{
		    return lowb;
		}
		else
		{
		    return highb;
		}
	    }

	    cur=arr[pos];
	    if (cur==val)
	    {
		return pos;
	    }
	    else if (cur>val)
	    {
		lowb=pos;
	    }
	    else
	    {
		highb=pos;
	    }
	    //cout<<lowb<<" "<<pos<<" "<<highb<<endl;
	}


    }
}

// randomise the order of a section (from bidx to eidx) of an array by swap elements ss times

int randomisearray (size_t* rndidx, size_t bidx, size_t eidx, size_t ss)
{

    gsl_rng* rng;
    size_t i, k, j, vpnum, swp;


    rng=gsl_rng_alloc(gsl_rng_taus);
    gsl_rng_set(rng, time(NULL));

    vpnum=eidx-bidx;

    for(i=0;i<ss;i++)
    {
	
	k=gsl_rng_uniform(rng)*vpnum+bidx;
	j=gsl_rng_uniform(rng)*vpnum+bidx;
	swp=rndidx[k];
	rndidx[k]=rndidx[j];	
	rndidx[j]=swp;
    }

    gsl_rng_free(rng);
    return 0;
}

size_t checkmemoryavb()
{
    
    size_t pages, pages_size;

    pages=sysconf(_SC_PHYS_PAGES);
    pages_size=sysconf(_SC_PAGE_SIZE);

    
    return pages*pages_size;
}

int sepbandnames(string stacked_band_names, int bands, vector<string>& bandnames)
{
    string st, oneband;
    int i, pos, ss;

    st=stacked_band_names;

    for(i=0;i<bands-1;i++)
    {
	pos=st.find(',');
	oneband=st.substr(0, pos);
	bandnames.push_back(oneband);
	ss=st.size();
	st=st.substr(pos+1, ss-pos-1);
    }
    oneband=st;
    bandnames.push_back(oneband);
    return 0;
}


long filecheckfilesize(string filename)
{
    ifstream fin;
    long length;

    fin.open(filename.c_str(), ios::binary);
    if (!fin.good())
    {
	return 0;
    }

    fin.seekg(0, ios::end);
    length=fin.tellg();
    fin.close();

    return length;


}

int fillarray(float* data, float val, long ss)
{
    long i;
    for(i=0;i<ss;i++)
    {
	data[i]=val;
    }
    return 0;
}
int fillarray(long* data, float val, long ss)
{
    long i;
    for(i=0;i<ss;i++)
    {
	data[i]=val;
    }
    return 0;
}
int fillarray(double* data, float val, long ss)
{
    long i;
    for(i=0;i<ss;i++)
    {
	data[i]=val;
    }
    return 0;
}

string filterstring(string st)
{
    long i, ss;

    string purest;

    char c;

    ss=st.size();
    
    for(i=0;i<ss;i++)
    {
	c=st[i];
	if ((c>=' ' && c<='~') || c=='\t' || c=='\n')
	{
	    purest=purest+c;
	}
    }
    return purest;
}
