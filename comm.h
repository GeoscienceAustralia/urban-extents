#include <iostream>
#include <iomanip>
#include <fstream>
#include <sstream>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <stdio.h>
#include <string>
#include <vector>
#include <unistd.h>
#include <time.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>
#include <gsl/gsl_blas.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_math.h>
#include <gsl/gsl_cblas.h>
#include <gsl/gsl_statistics.h>
#include <gsl/gsl_combination.h>
#include <gsl/gsl_rng.h>
#include <gsl/gsl_sort.h>
#include <gsl/gsl_sort_float.h>
#include <gsl/gsl_randist.h>
#include <gsl/gsl_cdf.h>
#include <gsl/gsl_eigen.h>
#include <gsl/gsl_fit.h>
#include <omp.h>



#define HAVE_INLINE 
using namespace std;

struct cone
{
    int _pos;
    int _neg;
    int* _index;
    gsl_matrix* _A;
    gsl_matrix* _LU;
    gsl_permutation* _p;
    gsl_vector* _x;
    //	vector<int> _spanlist;
};

struct envihdr
{
    string description;
    int samples;
    int lines;
    int bands;
    int header_offset;
    string file_type;
    int data_type;
    string interleave;
    string sensor_type;
    int byte_order;
    int xstart;
    int ystart;
    string map_info;
    string wavelength_units;
    string band_names;
    string wavelength;
    string projection_info;
    string coordinate_system_string;
};

struct svminfo
{
    double* a;
    double rsq;
    double sum;
    int svnum;
    int* svind;
    int nc;
    int* svcuts;
};

struct Rblock
{
    int bx, by;
    int x1, y1, x2, y2;
    int vp;      // number of valid pixels
    int seeds;	 // number of reference pixels 
    int* idx;	 // index of reference pixels
    double* norms;  // norms of pixels 
};



// Find the directory and the name of the file specified by wholename, return the directory and the file name which are in
// string filename and dirc, for example, 
// wholename="/mydata/abc/foo.data", then the function return
// filename="foo.data"
// dirc="/mydata/abc/"
//
int find_filename(char* wholename, string& filename, string& dirc); 
int find_filename(string wname, string& filename, string& dirc); 

// covert an integer to a string 
string itos(int i);

// Read a remote sensing time series image file and divide it into a number of small files, the file must be in BSQ format
// ifname, name of input file
// parts, the number of subset the program intends to divide the input file into
// pnum, the total number of the pixels
// ts, the number of time series (band) contained in the image file
// sf, the number of bytes per pixels in the input file
//
int div_afile(char* ifname, int parts, int pnum, int ts, int sf);

// Read a RS image file generated by dividing a large RS image file using the function divide_afile
// ifname, the name of the image file
// header, store the information of the image files, the number of pixels per time sequence, the number of time series, the number of bytes per pixels 
// in the image file    
int read_subfile(const char* ifname, float*& data, int*& header, int cls);

// Counting the number of lines and the number of items in each line of a text based data file, the number of instances of each line
// are stored at vector items, the input file stream is specified by fin and the delimited char is specified by det
int countlines(ifstream& fin, vector<int>& items);

// Counting the number of lines in the file
int countlines(string fname);


// reading data from a text based data file, store the data into array data in row order, ignoring the first coln columns, 
//the number of instances of each line are stored at vector items, the input file 
//is specified by ifname and the delimited char is specified by det

int readtxtdata(const char* ifname, int coln, double*& data, vector<int>& items);


int readtxtdata(const char* ifname, int nrow, int coln, double*& data, vector<int>& items);
int readtxtdata(const char* ifname, int nrow, int coln, double*& data, vector<int>& items, long&, long&);

// form index of combination vectors from multiple classes, the number of distinct instances of each class is specified by s and the returning index
// vectors is stored in comb, e.g., (5, 4, 3) -> (0,0,0), (0,0,1), ..., (2, 3, 2), (3, 0, 0), ..., (4,3,2), to generate combinations that with various 
// number of vector, put ad=1, in such cases vector (2, -1, 3) means a two-component vector (2,3), otherwise, set ad=0; 
int getcomb(vector<int>& s, vector< vector<int> >& comb, int ad);

// find an orthonormal base in from a set of m independent (n-dimensional) vectors specified by row vectors in gms
int orthonormalize(gsl_matrix* gms, int n, int m);


// generate a set of endmember signatures with orthonormal base by combining distinct EM signatures values of each endmember in libraries, 
// the EM signature library is given by array em, number of signatures for each EM class is given by vector its, the returned orthonormal EM sets
// are stored in emsets and the original EM sets are stored into og_emsets
int orthonormalemsets(vector<int>& its, int band, vector< vector<int> >& comb_ind, double** em, vector<gsl_matrix*>& emsets, vector<gsl_matrix*>& og_emsets );

// print the values of a matrix
int showmatrix(gsl_matrix* m);

//print the value of a vector
int showvector(gsl_vector* v);

// find the optimal endmember set of a pixel at a given time by finding EM set resulted in minimum projection angle
// return the index number of em set and the projection angle
int findoptimalemset(vector<gsl_matrix*>& emsets, vector<gsl_matrix*>& og_emsets, int pnum, int pind, int tind, int band, float** data, int& em_ind, double& angle, vector<double>& rcoefs, vector<int>& rngind, vector<vector<int> >& comb_ind);


// Project vector vd onto the subspace specified by vector set eml, return the projected vector in form of coefficients for the original vectors,
// the angle between  vd and the projected vector is put into angle, angle \in [0, pi] 
int em_projection(gsl_matrix* eml, gsl_matrix* oeml, gsl_vector* vd, vector<double>& coefs, double& angle);

// Normalize elements in coefs, so that they sum to 1
int normalweight(vector<double>& coefs);

// check if all elements in coefs are positive 
bool allpositive(vector<double>& coefs);


// check B G R reflectance reading of vb, if they are not all zero, return true, otherwise, return false
bool checkrgb(gsl_vector* vb);

// checking if a particular band of data at a given time sequence , if they are not all zero, return true
// otherwise, return false
bool checkts(float** data, int band, int pnum, int tind);


// Output a set a matrix to a file, it is assumed that the matrices will have identical dimensions, 
// The first line of the output file 
int outputemsets(const char* ofname, vector<gsl_matrix*>& msets);

// output a vector of integer to a file, the items will be separated by character det,  
// each line consists of n items, if n<0, there will be no line break in the file.
int outputvector(const char* ofname, vector<int>& msets, char det, int n);



// Reading data from a binary file, the length of the header is specified in h, the content of header and data is put into header and data
// sf is the size of the specify data type, if the files stores double data, set sf=sizeof(double), if it is float, set sf=sizeof(float)
int readbinfile(const char* ifname, double*& data, double*& header, int h);
int readbinfile_int(const char* ifname, int*& data, int*& header, int h);
int readbinfile_float(const char* ifname, float*& data, float*& header, int h);
int readbinfile_char(const char* ifname, char*& data, char*& header, int h);
int readbinfile_short(const char* ifname,  short*& data,  short*& header, int h);
// sort combination of EM sets in order of number of EMs in the combinations, return the index when the number of EMs change
//
int sort_comb(vector< vector<int> >& comb, vector <int>& cind);


// output a vector of vector of integer to a file, the items will be separated by character det,  
// each line consists of all items from a vector of integer
int outputvectorvector(const char* ofname, vector< vector<int> >& msets, char det);



// Find the first line which containing a specific marker in a text file 
//

int findmarker(ifstream& fin, string marker, string& st, int hits);
// Find the maximum value of a list specified band from a time series
// data - time series of all bands
// mdata - store the results, the mdata will have identical number of band as data, the number of time series of mdata will be equivalent to 
// the number of bands specified by maxind
// pnum - the number of pixels
// ts - the number of time series
// band - the number of band
// maxind - a list of the index of band which the maximum value in the time series will be found
// st -- the string contains the marker

int findmdata(float** data, float**& mdata, int pnum, int ts, int band, vector<int>& maxind);

int findallexterme(float** data, float** mdata, int pnum, int ts);


// output an array of data into a text file, the number of columns is set in icol, the 
// data is delimited by character det, 
// total -- the total number of the data
int writetxtfile_float(ofstream& fout, float* data, char det, int icol, int total, int offs);


// output an array of data into a text file, the number of columns is set in icol, the 
// data is delimited by character det, 
// total -- the total number of the data
int writetxtfile_double(ofstream& fout, double* data, char det, int icol, int total, int offs);


// Read a block of data from a (Time series) image file
// The procedure will read k blocks of data from fin into array data
// pos - the number of blocks offset from beginning of the fin
int readimg(ifstream& fin, float*& data, int pnum, int pos, int k);


// Output a envi header file
int writeenviheader(string ofname, string des, int samples, int lines, int bands, int datatype, string interleave, 
	int xstart, int ystart, string mapinfo,  string wavelengthunit, vector<string>& bandnames);

int writeenviheader(string ofname, string des, int samples, int lines, int bands, int datatype, string interleave, 
	int xstart, int ystart, string mapinfo,  string wavelengthunit, vector<string>& bandnames, string projection_info, string coor_string);


// allocate memory to an cone object
cone* createcone(cone*& onecone, int band, int* cndind, float** data);


// release memory and objects allocated to an cone object
int deletecone(cone*& onecone);


int emfind_onepixel(float** data, int ind, int band, cone** S, int *slist, bool* F,
	double* pos, double* zero, double* neg, size_t* sortindexs, int* cndind,  int& ptr_S, 
	vector<int>* ptoem, int& ptr_pto);

// replace vector (of index rdi) with vector (of index cdi) in every cone* involving vector of index rdi
int reponevector(int rdi, int ind, int band, cone** S, int cdi, int* slist, bool* F, float** data,
	vector<int>* ptoem, int& ptr_pto);

double pj_angle(float* vb, float* vd, int band);


// Classify a pixel, put it into one of the following four EM: BS, GV, NPV, WATER
int classifyem(float** data, int ind);

// Classify a pixel, put it into one of the following four EM: BS, GV, NPV, WATER
int classifyem_v1(float* data, string& lab);

// Classify a pixel, put it into one of the following four EM: BS, GV, NPV, WATER
int classifyem_v2(float* data, string& lab);

// Classify a pixel, put it into one of the following four EM: BS, GV, NPV, WATER, 
// using the results from MML decision graph program
int classifyem_v3(float* data, string& lab);

// Pivot a_ij in linear programming, b is used as temporary storage and must have identical dimension with a
//int pivot(double** a, double** b, int i, int j, int m, int n, bool& turn);
int pivot(double**& a, double**& b, int i, int j, int m, int n);




// Solve a standard minimum linear programming problem
int standardlpmin(double**& a, double**& b, int* mf, int m, int* nf, int n);


int onepivot(double**& a, double**& b, int* mf, int m, int* nf, int n);



// Generate a random vector whose sum of its elements >= lob and <= upb

int gensimplex(gsl_rng* rng, double lob, double upb, double* pr, int s);



// copy row x col content from a matrix (or part of a matrix, which can be larger than row x col)

int msacpy(double** des, double** src, int row, int col);

// copy row x col content from a matrix (or part of a matrix, which can be larger than row x col)
int msacpy_float(float** des, float** src, int row, int col);
// Eliminate the equalities in the linear programming program
int elsomerows(double**& a, double**& b, int lfcol, int rtcol, int* mf, int &m, int* nf, int& n);

// Solve the linear programming problem and store the results in array est
int solvelpmin(double** a, double** b, int* mf, int m, int* nf, int n);
// Solve the linear programming problem and store the results in array est
int solvelpmin(double** a, double** b, int* mf, int m, int* nf, int n, double* est);

int dispvector_int(int* a, int len, int w);

int dispvector(double* a, int len, int w);

int dispmatrix(double** a, int row, int col, int w);

int dispvector_float(float* a, int len, int w);

int dispmatrix_float(float** a, int row, int col, int w);

//Randomly select a set of vectors as EM set
int initemsv1(float** data, int chs, int band, gsl_rng* rng, int seeds, double** msa, int& m, int& n, 
	double lob, double upb, int* eminds, int& pems, int* mmf);

//Randomly select a set of vectors as EM set
int initems(float** data, int chs, int band, gsl_rng* rng, int seeds, double** msa, int& m, int& n, 
	double lob, double upb, int* pcls, int* eminds, int& pems, int* mmf);

// Write 6 index of EMs and corresponding abundance estimation of a pixel to the output file
int outputest(ofstream& fout, int* eminds, double* est, int m, int band, float* cot, 
	int* hits, double hitsth, int* mmf, int pems  );

// Add new endmember, updata LP matrix and EM sets
int updateems(double** mmsa, double** msa, int* eminds, int& m, int& n, int& pems,
	int pindex, float** data, int band, int* mmf, int cc);


int shrinkems(int cc, double** mmsa, double** msa, int& m, int& n, int* mmf, int* eminds, int* hits, 
	int band, int pems, double lob, double upb);


int transtime( int t, int &dd, int&hh, int& mm, int& secs);

//Redelimit a txt file with a new delimit character
int delimitedtxt(string ifname, char* indet, int len, char outdet, string ofname);



int findtspara(float* data, float* mdata, int ts, int nms);


// calculate the distance matrix for a set of pixels, the distance is defined as projective angle between two vectors
int   calnnmat(double** nnmat, int trs, int* nninds, int band, float** a);



int openintxtfile(string ifname, ifstream& fin);

int openouttxtfile(string ofname, ofstream& fout);

int readdatafile(string ifname, float**& data, int&, int&);
int readdatafile(string ifname, double**& data, int&, int&);
int writedatafile(string ofname, float** data, int irow, int icol, char det);


string ftostr( float value );

string itostr( int value );
string longtostr( long value );

int zotransform(float** data, int irow, int icol, float* scf);

int creatematrix(float**& data, int irow, int icol);
int creatematrix(double**& data, int irow, int icol);
int creatematrix(bool**& data, int irow, int icol);

int deletematrix(bool**& data, int irow);
int deletematrix(float**& data, int irow);
int deletematrix(double**& data, int irow);

int addfeatures(float** msa, float** & data, int irow, int band);
int addfeatures(float** msa, float** & data, int irow, int band, int* pcls);

string trim(const string& st);


int msbcpy(double**& des, double** src, int row, int col);


int msbcpy_float(float**& des, float** src, int row, int col);


// Check a pixel to see if it can be placed into LP matrix
int checkems(float** data, int band, int ind);


int unmixems(double** ma, int dm, bool*  tyma);


int creatematrix(double**& data, int irow, int icol, double t);
int setmatrix(double**& data, int irow, int icol, double t);

int deletematrix(int**& data, int irow);
int creatematrix(int**& data, int irow, int icol);

int unmixasubsetv1(double** mma, int m, int n, int* mmf, int band, double upb, double lob, float** data, int bidx, 
	int eidx, float* cot);
// unmix a set of pixels
int unmixasubset(double** mma, int m, int n, int* mmf, int band, double upb, double lob, float** data, int bidx, 
	int eidx, float* cot);

// unmix a set of pixels
int unmixasubset(double** mma, int m, int n, int* mmf, int band, double upb, double lob, float** data, int* pcls, int bidx, 
	int eidx, float* cot, size_t* sts);

// Unmix one pixel using the LP algorithm, mma stores the LP matrix while mmf stores the corresponding index of vector
int unmixonepixel(double** mma, int m, int n, int* mmf, int band, double upb, double lob, int ind, float** data, float* cot);


int resetlpmatrix(int cc, double** mmsa, double** msa, int &m, int &n, int* hits, int* mmf, int* eminds, int upm);

int resetlpmatrix(int cc, double** mmsa, double** mma, int &m, int &n, int* hits, int* mmf, int* eminds, int upm, int* bdays);

int unmixasubset(double** mma, int m, int n, int* mmf, int band, double upb, double lob, float** data, 
	int* pcls, int bidx, int eidx, float* cot);

// unmix a set of pixels
int unmixasubset(double** mma, int m, int n, int* mmf, int band, double upb, double lob, float** data, int bidx, 
	int eidx, float* cot, int* ida);

int filterdata(float**& data, int& irow, int icol, float thod);

int filterdata(double**& data, int& irow, int icol, float thod);

//Randomly select a set of vectors as EM set
int initemsv2(float** data, int band, int* ida, int seeds, double** msa, int& m, int& n, 
	double lob, double upb, int* eminds, int*bdays,  int& pems, int* mmf);

int readhdrfile(string ifname, envihdr& ehd);
int exthdrmapinfo(string mapinfo, double& lat, double& lon, double& lat_step, double& lon_step);


// Unmix a rectangle block of Landsat image, the whole image is stored in img in row order, 
// the position of the top left corner is located at by rindex (row index), cidenx (column index)
// ncol -- the number of columns in the whole imagery
// irow -- the number of rows in the block
// icol -- the number of columns in the block
// flc -- fractional land cover estimations for each pixel in the block in row order
// ems -- spectral values (6 bands), label, x, y coordinates of the endmembers found in the block
// ne -- the number of endmembers found in the block
//
// tpoints, training samples in new feature space, each sample represented by a row in the matrix
// acls -- the labels of the training samples
// icvm -- the inverse of the covariance matrix, 

int unmixablock(float** img, int ncol, int rindex, int cindex, int irow, int icol, double**& flc, float**& ems, int& ne, 
	gsl_matrix* mp, gsl_matrix* tpoints, int* acls,  gsl_matrix* icvm);

svminfo* createsvminfo(int bs);

int deletesvminfo(svminfo* svf);

// Find the index number of the element of arr  which has the closest value to val, the arr had been sorted in either ascending and descending order
size_t find_closest_value_index(double val, double* arr, size_t maxidx, int direction);

int randomisearray (size_t* rndidx, size_t bidx, size_t eidx, size_t ss);

// check total system memory available to the program
size_t checkmemoryavb();

int sepbandnames(string stacked_band_names, int bands, vector<string>& bandnames);

long filecheckfilesize(string filename);
int fillarray(float* data, float val, long ss);
int fillarray(long* data, float val, long ss);
int fillarray(double* data, float val, long ss);
string filterstring(string st);
